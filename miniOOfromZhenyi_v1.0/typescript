Script started on Mon Apr 11 00:49:08 2016
[?1034hbash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	y	h

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 2	left: r	equals cmd:1
proc y:
p = cmd:2;
p	cmd: 2	in proc now.
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 172, characters 4-16:
Error: This function has type string -> unit
       It is applied to too many arguments; maybe you forgot a `;'.
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	y	h

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 2	left: r	equals cmd:1
proc y:
p = cmd:2;
p	cmd: 2	in proc now.
test now type is proc.
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	y	h

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 2	left: r	equals cmd:1
proc y:
p = cmd:2;
p	cmd: 2	in proc now.
test now type is proc.
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	y	h

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 2	left: r	equals cmd:1
proc y:
p = cmd:2;
p	cmd: 2	in proc now.
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	y	h

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 2	left: r	equals cmd:1
proc y:
p = cmd:2;
p	cmd: 2	in proc now.
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 207, characters 4-5:
Error: Syntax error: operator expected.
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 200, characters 7-227:
Error: This expression has type unit
       This is not a function; it cannot be applied.
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 200, characters 7-227:
Error: This expression has type unit
       This is not a function; it cannot be applied.
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 208, characters 4-5:
Error: Syntax error
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 208, characters 4-5:
Error: Syntax error
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 211, characters 2-6:
Error: Syntax error
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	y	h

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 2	left: r	equals cmd:1
proc y:
p = cmd:2;
p	cmd: 2	in proc now.
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 201, characters 4-7:
Error: Syntax error: operator expected.
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 201, characters 4-7:
Error: Syntax error: operator expected.
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	typemake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 1095make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	y	h

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 2	left: r	equals cmd:1
proc y:
p = cmd:2;
p	cmd: 2	in proc now.
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	y	h

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 2	left: r	equals cmd:1
proc y:
p = cmd:2;
p	cmd: 2	in proc now.
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	y	h

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 2	left: r	equals cmd:1
proc y:
p = cmd:2;
p	cmd: 2	in proc now.
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	y	h

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 2	left: r	equals cmd:1
proc y:
p = cmd:2;
p	cmd: 2	in proc now.
test now type is proc.
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	y	h

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 2	left: r	equals cmd:1
proc y:
p = cmd:2;
p	cmd: 2	in proc now.
test now type is proc.
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, tablemake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calcumake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 178, characters 4-7:
Error: Syntax error: ')' expected
File "calculatorYACC.mly", line 172, characters 21-22:
Error: This '(' might be unmatched
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 179, characters 4-7:
Error: Syntax error: ')' expected
File "calculatorYACC.mly", line 172, characters 21-22:
Error: This '(' might be unmatched
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	y	h

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 2	left: r	equals cmd:1
proc y:
p = cmd:2;
p	cmd: 2	in proc now.
test now type is proc.
test now type is proc.
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 176, characters 25-31:
Error: This expression has type string * (string * (string * int))
       but an expression was expected of type string
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	y	h

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 2	left: r	equals cmd:1
proc y:
p = cmd:2;
p	cmd: 2	in proc now.
test now type is proc.
test now type is proc.
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	y	h

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 2	left: r	equals cmd:1
proc y:
p = cmd:2;
p	cmd: 2	in proc now.
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	y	h

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 2	left: r	equals cmd:1
proc y:
p = cmd:2;
p	cmd: 2	in proc now.
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	y	h

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 2	left: r	equals cmd:1
proc y:
p = cmd:2;
p	cmd: 2	in proc now.
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1
make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	y	h

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 2	left: r	equals cmd:1
proc y:
p = cmd:2;
p	cmd: 2	in proc now.
test now type is proc.
now in declare proc.
proc: p	para: y	cmd: 2
proc: 2	p

2
h = cmd:3;
h	def:D	type:int	value:3
p	def:U	type:proc	value:2
y	def:U	type:nil	value:0

p
4
2(4)
p	cmd: 2	4
para: y=4
run cmd: 2
assignment:	r = cmd: 1
rec call: 
0

y
y	def:U	type:nil	value:0

1
1
p = cmd:1;
p	def:U	type:int	value:1
y	def:U	tymake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mllmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	y	h

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 2	left: r	equals cmd:1
proc y:
p = cmd:2;
p	cmd: 2	in proc now.
now in declare proc.
proc: p	para: y	cmd: 2
2
h = cmd:3;
h	def:D	type:int	value:3
p	def:U	type:proc	value:2
y	def:U	type:nil	value:0

p
4
2(4)
p	cmd: 2	4
para: y=4
run cmd: 2
assignment:	r = cmd: 1
rec call: 
0

y
y	def:U	type:nil	value:0

1
1
p = cmd:1;
p	def:U	type:int	value:1
y	def:U	type:nil	value:0

p
p	def:U	type:int	value:1
y	def:U	type:nil	value:0

y
p	def:U	type:int	value:1
y	def:U	type:nil	value:0

1
1(0)
nil	cmd: 1	0
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 347, characters 4-5:
Error: Syntax error
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 66, characters 71-99:
Warning 10: this expression should have type unit.
File "calculatorYACC.mly", line 66, characters 177-192:
Error: This expression has type unit but an expression was expected of type
         string
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 261, characters 17-19:
Error: This expression has type int but an expression was expected of type
         string
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 266, characters 2-3:
Error: Syntax error
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 264, characters 18-20:
Error: This expression has type int but an expression was expected of type
         string
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 261, characters 13-37:
Error: This expression has type int but an expression was expected of type
         unit
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 350, characters 43-47:
Error: Unbound value name
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	0	2

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 3	left: r	equals cmd:1
proc y:
p = cmd:3;
p	cmd: 3	in proc now.
now in declare proc.
proc: p	para: y	cmd: 3
2
h = cmd:4;
h	def:D	type:int	value:4
p	def:U	type:proc	value:3
y	def:U	type:nil	value:0

p
4
3(5)
p	cmd: 3	5
para: y=5
run cmd: 3
assignment:	r = cmd: 1
rec call: 
0

y
y	def:U	type:nil	value:0

1
1
p = cmd:1;
p	def:U	type:int	value:1
y	def:U	type:nil	value:0

p
p	def:U	type:intmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli mmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 315, characters 19-22:
Error: Syntax error
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	0	2

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 3	left: r	equals cmd:1
proc y:
p = cmd:3;
p	cmd: 3	in proc now.
now in declare proc.
proc: p	para: y	cmd: 3
2
h = cmd:4;
h	def:D	type:int	value:4
p	def:U	type:proc	value:3
y	def:U	type:nil	value:0

p
4
3(5)
p	cmd: 3	5
para: y=5
run cmd: 3
assignment:	r = cmd: 1
rec call: 
0

y
y	def:U	type:nil	value:0

1
1
p = cmd:1;
p	def:U	type:int	value:1
y	def:U	type:nil	value:0

p
p	def:U	type:intmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli mmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 43, characters 1-2:
Error: Syntax error
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	0	2

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 3	left: r	equals cmd:1
proc y:
p = cmd:3;
p	cmd: 3	in proc now.
now in declare proc.
proc: p	para: y	cmd: 3
2
h = cmd:4;
h	def:D	type:int	value:4
p	def:U	type:proc	value:3
y	def:U	type:nil	value:0

p
4
3(5)
p	cmd: 3	5
para: y=5
run cmd: 3
assignment:	r = cmd: 1
left not found.
rec call: 
-1

y
y	def:U	type:nil	value:0

1
1
p = cmd:1;
p	def:U	type:int	value:1
y	def:U	type:nil	value:0

p
p	def:U	type:int	value:1
y	def:U	type:nil	value:0

y
p	def:U	type:int	value:1
y	def:U	type:nil	value:0

1
1(0)
nil	cmd: 1	0
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 297, characters 2-6:
Error: Syntax error: ')' expected
File "calculatorYACC.mly", line 284, characters 37-38:
Error: This '(' might be unmatched
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	0	2

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 3	left: r	equals cmd:1
proc y:
p = cmd:3;
p	cmd: 3	in proc now.
now in declare proc.
proc: p	para: y	cmd: 3
2
h = cmd:4;
h	def:D	type:int	value:4
p	def:U	type:proc	value:3
y	def:U	type:nil	value:0

p
4
3(5)
p	cmd: 3	5
para: y=5
run cmd: 3
assignment:	r = cmd: 1
binary operation:	0	+	2
6
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make[Kmake delete
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	0	2

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 3	left: r	equals cmd:1
proc y:
p = cmd:3;
p	cmd: 3	in proc now.
now in declare proc.
proc: p	para: y	cmd: 3
2
h = cmd:4;
h	def:D	type:int	value:4
p	def:U	type:proc	value:3
y	def:U	type:nil	[Kmake delete
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.mmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	0	2

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 3	left: r	equals cmd:1
proc y:
p = cmd:3;
p	cmd: 3	in proc now.
now in declare proc.
proc: p	para: y	cmd: 3
2
h = cmd:4;
h	def:D	type:int	value:4
p	def:U	type:proc	value:3
y	def:U	type:nil	value:0

p
4
3(5)
p	cmd: 3	5
para: y=5
run cmd: 3
assignment:	r = cmd: 1
binary operation:	0	+	2
5	+	1
6
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
bash-3.2$ vim typescri[K[K[K[K[K[K[K[K[K[K[K[Kgedit t[Kmakefile 
bash: gedit: command not found
bash-3.2$ gedit makefile [K[K[K[K[K[K[K[K[K[K[K[K[K[K[Kedit makefile 
bash: edit: command not found
bash-3.2$ cat makefile 
all: delete
	ocamllex calculatorLEX.mll
	ocamlyacc calculatorYACC.mly
	ocamlc -c calculatorYACC.mli
	ocamlc -c calculatorLEX.ml
	ocamlc -c calculatorYACC.ml
	ocamlc -c calculator.ml
	@echo "# linking of the lexer, parser & calculator:"
	ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
	ls
	@echo "# using the miniOO:"
	@echo "var r; var h; h=1; var p; p = proc y: r = y+h; var h; h=2; p(4);" | ./calculator
	@echo "var p; p = proc y:if y < 1 then p = 1 else p(y - 1); p(1)" | ./calculator
	@echo "# the end."

delete:
	/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~bash-3.2$ cat makefile 
all: delete
	ocamllex calculatorLEX.mll
	ocamlyacc calculatorYACC.mly
	ocamlc -c calculatorYACC.mli
	ocamlc -c calculatorLEX.ml
	ocamlc -c calculatorYACC.ml
	ocamlc -c calculator.ml
	@echo "# linking of the lexer, parser & calculator:"
	ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
	ls
	@echo "# using the miniOO:"
	@echo "var r; var h; h=1; var p; p = proc y: r = y+h; var h; h=2; p(4);" | ./calculator
	
	@echo "# the end."

delete:
	/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~bash-3.2$ cat makefile [C[C[C[C[C[C[C[C[C[C[Kmaked[K delete
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
bash-3.2$ make delete
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	0	2

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 3	left: r	equals cmd:1
proc y:
p = cmd:3;
p	cmd: 3	in proc now.
now in declare proc.
proc: p	para: y	cmd: 3
2
h = cmd:4;
h	def:D	type:int	value:4
p	def:U	type:proc	value:3
y	def:U	type:nil	value:0

p
4
3(5)
p	cmd: 3	5
para: y=5
run cmd: 3
assignment:	r = cmd: 1
binary operation:	0	+	2
5	+	1
6
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	0	2

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 3	left: r	equals cmd:1
proc y:
p = cmd:3;
p	cmd: 3	in proc now.
now in declare proc.
proc: p	para: y	cmd: 3
2
h = cmd:4;
h	def:D	type:int	value:4
p	def:U	type:proc	value:3
y	def:U	type:nil	value:0

p
4
3(5)
p	cmd: 3	5
para: y=5
run cmd: 3
assignment:	r = cmd: 1
binary operation:	0	+	2
5	+	1
6
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculamake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	0	2

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 3	left: r	equals cmd:1
proc y:
p = cmd:3;
p	cmd: 3	in proc now.
now in declare proc.
proc: p	para: y	cmd: 3
2
h = cmd:4;
h	def:D	type:int	value:4
p	def:U	type:proc	value:3
y	def:U	type:nil	value:0

p
4
3(5)
p	cmd: 3	5
para: y=5
run cmd: 3
assignment:	r = cmd: 1
binary operation:	0	+	2
5	+	1
6
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyicript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	0	2

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 3	left: r	equals cmd:1
proc y:
p = cmd:3;
p	cmd: 3	in proc now.
now in declare proc.
proc: p	para: y	cmd: 3
2
h = cmd:4;
h	def:D	type:int	value:4
p	def:U	type:proc	value:3
y	def:U	type:nil	value:0

p
4
3(5)
p	cmd: 3	5
para: y=5
run cmd: 3
assignment:	r = cmd: 1
binary operation:	0	+	2
5	+	1
6
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

0	y	+	1	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 1	op: +	0	2

r = cmd:1;
r	cmd: 1	in proc now.
cmd: 3	left: r	equals cmd:1
proc y:
p = cmd:3;
p	cmd: 3	in proc now.
now in declare proc.
proc: p	para: y	cmd: 3
2
h = cmd:4;
h	def:D	type:int	value:4
p	def:U	type:proc	value:3
y	def:U	type:nil	value:0

p
4
3(5)
p	cmd: 3	5
para: y=5
run cmd: 3
assignment:	r = cmd: 1
binary operation:	0	+	2
5	+	1
6
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
h = cmd:0;
h	def:U	type:int	value:1

y
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
2
h = cmd:6;
h	def:D	type:int	value:6
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

p
4
5(7)
p	cmd: 5	7
para: y=7
run cmd: 5
assignment:	r = cmd: 3
binary operation:	1	+	4
7	+	1
8
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 98, characters 19-25:
Error: This expression has type cmdTable ref
       but an expression was expected of type (int * string) list
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num
h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	varcmd: 0:	num
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	varcmd: 1:	varcmd: 0:	num
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	numcmd: 2:	varcmd: 1:	varcmd: 0:	num
cmd: 1:	varcmd: 4:	numcmd: 2:	varcmd: 1:	varcmd: 0:	num
cmd: 3:	binopcmd: 1:	varcmd: 4:	numcmd: 2:	varcmd: 1:	varcmd: 0:	num
cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
2
cmd: 6:	numcmd: 3:	binopcmd: 1:	varcmd: 4:	numcmd: 2:	varcmd: 1:	varcmd: 0:	num
h = cmd:6;
h	def:D	type:int	value:6
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

p
4
cmd: 7:	numcmd: 6:	numcmd: 3:	binopcmd: 1:	varcmd: 4:	numcmd: 2:	varcmd: 1:	varcmd: 0:	num
5(7)
p	cmd: 5	7
para: y=7
run cmd: 5
assignment:	r = cmd: 3
binary operation:	1	+	4
7	+	1
8
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
2
cmd: 6:	num
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

h = cmd:6;
h	def:D	type:int	value:6
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

p
4
cmd: 7:	num
cmd: 6:	num
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

5(7)
p	cmd: 5	7
para: y=7
run cmd: 5
assignment:	r = cmd: 3
binary operation:	1	+	4
7	+	1
8
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 108, characters 5-7:
Error: Syntax error: ')' expected
File "calculatorYACC.mly", line 94, characters 7-8:
Error: This '(' might be unmatched
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 97, characters 31-37:
Error: Unbound value except
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
In handleNum,
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
In handleNum,
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
whereamIFatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
2
cmd: 6:	num
cmd: 5:	ass
cmd: 3:	binop
cmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 185, characters 45-171:
Error: This expression has type unit
       This is not a function; it cannot be applied.
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 185, characters 45-184:
Error: This expression has type unit
       This is not a function; it cannot be applied.
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 185, characters 45-183:
Error: This expression has type unit
       This is not a function; it cannot be applied.
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 185, characters 45-171:
Error: This expression has type unit
       This is not a function; it cannot be applied.
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 186, characters 45-115:
Error: This expression has type unit
       This is not a function; it cannot be applied.
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
2
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
2
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
2
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 346, characters 4-5:
Error: Syntax error: operator expected.
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 346, characters 4-5:
Error: Syntax error: operator expected.
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
2
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
2
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

p
4
cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
p	cmd: 5	8
para: y=8
run cmd: 5
assignment:	r = cmd: 3
binary operation:	1	+	4
4	+	1
5
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatord: 3
binary operation:	1	+	4
4	+	1
5
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 345, characters 4-20:
Warning 10: this expression should have type unit.
File "calculatorYACC.mly", line 477, characters 116-135:
Error: This expression has type unit but an expression was expected of type
         int
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
2
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

p
4
cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
p	cmd: 5	8
para: y=8
run cmd: 5
assignment:	r = cmd: 3
binary operation:	1	+	4
4	+	1
5
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
2
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
2
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
2
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
2
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
2
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of tmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 307, characters 16-20:
Error: Syntax error: ')' expected
File "calculatorYACC.mly", line 301, characters 8-9:
Error: This '(' might be unmatched
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 308, characters 55-61:
Error: This expression has type (string * (string * (string * int))) list
       This is not a function; it cannot be applied.
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
2
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

p
4
cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
p	cmd: 5	8
para: y=8
run cmd: 5
assignment:	r = cmd: 3
binary operation:	1	+	4
4	+	1
5
r	def:D	type:int	value:5
y	def:T	type:nil	value:8
h	def:D	type:int	value:7
p	def:U	type:proc	value:5

whereamIrec call: 
5

y
cmd: 0:	var

y	def:U	type:nil	value:0

1
cmd: 1:	num
cmd: 0:	var

1
cmd: 2:	num
cmd: 1:	num
cmd: 0:	var

p = cmd:2;
p	def:U	type:int	value:1
y	def:U	type:nil	value:0

p
cmd: 3:	var
cmd: 2:	num
cmd: 1:	num
cmd: 0:	var

p	def:U	type:int	value:1
y	def:U	type:nil	value:0

y
cmd: 4:	var
cmd: 3:	var
cmd: 2:	num
cmd: 1:	num
cmd: 0:	var

p	def:U	type:int	value:1
y	def:U	type:nil	value:0

1
cmd: 5:	num
cmd: 4:	var
cmd: 3:	var
cmd: 2:	num
cmd: 1:	num
cmd: 0:	var

3(-1)
nil	cmd: 3	-1
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
2
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	typmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
2
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

p
4
cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
p	cmd: 5	8
para: y=8
run cmd: 5
assignment:	r = cmd: 3
binary operation:	1	+	4
4	+	1
5
r	def:D	type:int	value:5
y	def:T	type:nil	value:8
h	def:D	type:int	value:7
p	def:U	type:proc	value:5

rec call: 
5

y
cmd: 0:	var

y	def:U	type:nil	value:0

1
cmd: 1:	num
cmd: 0:	var

1
cmd: 2:	num
cmd: 1:	num
cmd: 0:	var

p = cmd:2;
p	def:U	type:int	value:1
y	def:U	type:nil	value:0

p
cmd: 3:	var
cmd: 2:	num
cmd: 1:	num
cmd: 0:	var

p	def:U	type:int	value:1
y	def:U	type:nil	value:0

y
cmd: 4:	var
cmd: 3:	var
cmd: 2:	num
cmd: 1:	num
cmd: 0:	var

p	def:U	type:int	value:1
y	def:U	type:nil	value:0

1
cmd: 5:	num
cmd: 4:	var
cmd: 3:	var
cmd: 2:	num
cmd: 1:	num
cmd: 0:	var

3(-1)
nil	cmd: 3	-1
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
2
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	typmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
2
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	typmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 118, characters 37-39:
Error: Syntax error: ')' expected
File "calculatorYACC.mly", line 118, characters 7-8:
Error: This '(' might be unmatched
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 455, characters 1-3:
Error: Syntax error: operator expected.
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 455, characters 4-6:
Error: Syntax error: ')' expected
File "calculatorYACC.mly", line 415, characters 31-32:
Error: This '(' might be unmatched
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 144, characters 14-22:
Error: Unbound value getValue
Hint: Did you mean getvalue?
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 144, characters 23-24:
Error: This expression has type int but an expression was expected of type
         string
make: *** [all] Error 2
bash-3.2$ make delete
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 144, characters 23-24:
Error: This expression has type int but an expression was expected of type
         string
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 118, characters 31-35:
Error: Syntax error: ')' expected
File "calculatorYACC.mly", line 118, characters 7-8:
Error: This '(' might be unmatched
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 144, characters 23-24:
Error: This expression has type int but an expression was expected of type
         string
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 463, characters 11-35:
Error: This expression has type int but an expression was expected of type
         bool
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 463, characters 11-35:
Error: This expression has type int but an expression was expected of type
         bool
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 463, characters 11-35:
Error: This expression has type int but an expression was expected of type
         bool
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 421, characters 0-1:
Error: Syntax error
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 474, characters 1-3:
Error: Syntax error: ')' expected
File "calculatorYACC.mly", line 439, characters 35-36:
Error: This '(' might be unmatched
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 468, characters 12-129:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 476, characters 27-139:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 541, characters 23-40:
Error: This expression has type int but an expression was expected of type
         bool
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 476, characters 12-129:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 484, characters 27-139:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	vamake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 476, characters 12-129:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 484, characters 27-139:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 333, characters 8-9:
Error: Syntax error: operator expected.
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 27, characters 21-23:
Error: This expression has type 'a list
       but an expression was expected of type
         procCntTable = int * (int * int)
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 47, characters 18-20:
Error: This expression has type 'a list
       but an expression was expected of type
         condTable = int * (int * (int * int))
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 329, characters 39-45:
Error: This expression has type procList ref
       but an expression was expected of type (int * 'a) list
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 333, characters 22-33:
Error: Unbound value setProcPara
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 345, characters 33-56:
Error: This expression has type int * (int * int)
       but an expression was expected of type 'a * 'b * 'c
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 391, characters 46-58:
Error: This expression has type procCntTable ref
       but an expression was expected of type (int * (int * int)) list
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 523, characters 12-129:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 531, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 548, characters 19-58:
Error: This expression has type 'a * 'b
       but an expression was expected of type
         condTable = (int * (int * (int * int))) list
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 523, characters 12-129:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 531, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	vamake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 523, characters 12-129:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 531, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
2
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

p
4
cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 152, characters 2-3:
Error: Syntax error
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 152, characters 2-3:
Error: Syntax error
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 152, characters 2-3:
Error: Syntax error
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 309, characters 3-5:
Error: Syntax error: ')' expected
File "calculatorYACC.mly", line 290, characters 20-21:
Error: This '(' might be unmatched
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 313, characters 3-5:
Error: Syntax error: ')' expected
File "calculatorYACC.mly", line 290, characters 20-21:
Error: This '(' might be unmatched
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 298, characters 16-25:
Error: Unbound value handleNum
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 314, characters 14-26:
Error: Unbound value addDirectCmd
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 548, characters 12-129:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 556, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 314, characters 14-26:
Error: Unbound value addDirectCmd
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 548, characters 12-129:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 556, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
p	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:9;
p	cmd: 9	in proc now.
now in declare proc.
proc: p	para: y	cmd: 9
p
1
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	num
cmd: 6:	var
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

9(11)
p	cmd: 9	11
para: y=11
run cmd: 9
binary operation:	0	<	1
1	<	1
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	num
cmd: 6:	var
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

12
cmd not found in bop.
cmd id not found.
rec call: 
-1

# the end.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 548, characters 12-129:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 556, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	vamake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 548, characters 12-129:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 556, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
2
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

p
4
cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
p	cmd: 5	8
para: y=8
run cmd: 5
assignment:	r = cmd: 3
binary operation:	1	+	4
4	+	1
cmd: 9:	num
cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
c4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

12
cmd not found in bop.
cmd id not found.
rec call: 
-1

# the end.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 548, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 556, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	vamake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 548, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 556, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
2
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

p
4
cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
p	cmd: 5	8
para: y=8
run cmd: 5
assignment:	r = cmd: 3
binary operation:	1	+	4
4	+	1
cmd: 9:	num
cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
c:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

12
cmd not found in bop.
cmd id not found.
rec call: 
-1

# the end.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 552, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 560, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	vamake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 552, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 560, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 552, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 560, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 552, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 560, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
2
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
4
cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
p	cmd: 5	8
para: y=8
run cmd: 5
assignment:	r = cmd: 3
binary operation:	1	+	4
4	+	1
cmd: 9:	num
cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmracters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:2
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
find num:4
cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	racters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3
proc y:
p = cmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 552, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 560, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	varmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 552, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 560, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

1	y	+	2	h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmdmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 514, characters 2-6:
Error: Syntax error: ')' expected
File "calculatorYACC.mly", line 512, characters 4-5:
Error: This '(' might be unmatched
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 526, characters 2-3:
Error: Syntax error: operator expected.
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 486, characters 45-51:
Error: Unbound value paraid
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 499, characters 10-11:
Error: Syntax error
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 488, characters 33-38:
Error: Unbound value newid
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 596, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 604, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

found all the parameter.
r = cmd:0;
r	def:U	type:int	value:1
y	def:U	type:nmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 596, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 604, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

found all the parameter.
r = cmd:0;
r	def:U	type:int	value:1
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

proc y:
p = cmd:0;
p	def:U	type:proc	value:1
r	def:U	type:int	value:1
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find num:2
cmd: 3:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

h = cmd:3;
h	def:D	type:int	value:3
p	def:U	type:proc	value:1
r	def:U	type:int	value:1
y	def:U	type:nil	value:0

find var:p
cmd: 4:	var
cmd: 3:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

h	def:D	type:int	value:3
p	def:U	type:proc	value:1
r	def:U	type:int	value:1
y	def:U	type:nil	value:0

find num:4
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

4(5)
nil	cmd: 4	5
cmd: 6:	rec
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

rec call: 
6

# using the miniOO:
find var:y
cmd: 0:	var

y	d4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
p	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
1	<	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cmd not found in bop.
cmd id not found.
rec call: 
-1

# the end.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 101, characters 18-26:
Error: This expression has type procTable = (string * (string * int)) list
       but an expression was expected of type (int * string) list
       Type string is not compatible with type int 
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 596, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 604, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 101, characters 18-26:
Error: This expression has type procTable = (string * (string * int)) list
       but an expression was expected of type (int * string) list
       Type string is not compatible with type int 
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 596, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 604, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

found all the parameter.
r = cmd:0;
r	def:U	type:int	value:1
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

proc y:
p = cmd:0;
p	def:U	type:proc	value:1
r	def:U	type:in: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 8	op: -	6	7
cmd: 2	op: <	0	1

5(8)
nil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:1
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
p	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
1	<	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cmd not found in bop.
cmd id not found.
rec call: 
-1

# the end.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 596, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 604, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	nmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 596, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 604, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:1
cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:2
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:4
cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
p	cmd: 5	8
para: y=8
run cmd: 5
assignment:	r = cmd: 3
binary operation:	1	+	4
4	+	0
cmd: 9:	num
cmd: 8:	num
d: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:1
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
p	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
1	<	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cmd not found in bop.
cmd id not found.
rec call: 
-1

# the end.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 603, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 611, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	0
num:0:	1

cmd: 4:	num
cmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 603, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 611, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	0
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:2
num:7:	2
num:4:	0
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:4
num:8:	4
num:7:	2
num:4:	0
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
p	cmd: 5	6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
p	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
1	<	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cmd not found in bop.
cmd id not found.
rec call: 
-1

# the end.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 603, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 611, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:2
num:7:	2
num:4:	1
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:4
num:8:	4
num:7:	2
num:4:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
p	cmd: 5	8
para: y=8
run cmd: 5
assignment:	r = cmd: 3
binary operation:	1	+	4
4	+	1
num:9:	5
num:8:	4
num:7:	2
num:4:	1
num:0:	1

cmd: 9:	num
cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

9
r	def:D	type:int	value:9
y	def:T	type:nil	value:8
h	def:D	type:int	value:7
p	def:U	type:proc	value:5

rec call: 
5

# using the miniOO:
find var:y
cmd: 0:	var

y	def:U	type:nil	value:0

find num:1
num:1:	1

cmd: 1:	num
cmd: 0:	var

in handle lesser: not defined:	0cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 2	op: <	0	1

find num:1
num:3:	1
num:1:	1

cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p = cmd:3;
p	cmd: 3	in proc now.
cmd: 4	left: p	equals cmd:3

find var:p
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

find var:y
cmd: 6:	var
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

find num:1
num:7:	1
num:3:	1
num:1:	1

cmd: 7:	num
cmd: 6:	var
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

not found all the parameter.
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 8	op: -	6	7
cmd: 2	op: <	0	1

5(8)
nil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
p	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
1	<	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cmd not found in bop.
cmd id not found.
rec call: 
-1

# the end.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 606, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 614, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 606, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 614, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	1
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
ready md: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to runp	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
1	<	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false
cmd not found in bop.
cmd id not found.
rec call: 
-1

# the end.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 610, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 618, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 610, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 618, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	1
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
ready md: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to runp	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
1	<	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false9
cmd not found in bop.
cmd id not found.
rec call: 
-1

# the end.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 610, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 618, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 610, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 618, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	1
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
ready md: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to runp	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
1	<	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
cmd not found in bop.
cmd id not found.
rec call: 
-1

# the end.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 609, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 617, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 609, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 617, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	1
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
ready md: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to runp	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
1	<	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9
cmd not found in bop.
cmd id not found.
rec call: 
-1

# the end.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 608, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 616, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 608, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 616, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	1
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
ready md: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to runp	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
1	<	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
rec
handleCmd:9
cmd not found in bop.
cmd id not found.
rec call: 
-1

# the end.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 608, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 616, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 608, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 616, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	1
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
ready md: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to runp	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
1	<	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9
para name:y	run cmd:10
cmd not found in bop.
cmd id not found.
rec call: 
-1

# the end.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 608, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 616, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 608, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 616, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	1
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
ready md: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to runp	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
1	<	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9
para name:y	run cmd:10
binary operation:	0	<	1
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 605, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 613, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 605, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 613, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	1
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
ready 	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to runp	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
1
1
1	<	1
1
1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9
para name:y	run cmd:10
binary operation:	0	<	1
1
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 605, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 613, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 605, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 613, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	1
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
ready (8)
ready to runnil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to runp	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9
para name:y	run cmd:10
binary operation:	0	<	1
num:	1
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 606, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 614, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 606, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 614, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	1
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
ready (8)
ready to runnil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to runp	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9
para name:y	run cmd:10
y	def:T	type:nil	value:8
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 606, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 614, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 606, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 614, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	1
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
ready (8)
ready to runnil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to runp	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9with paraid:8
para name:y	run cmd:10
y	def:T	type:nil	value:8
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.(8)
ready to runnil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to runp	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9with paraid:8
para name:y	run cmd:10
y	def:T	type:nil	value:8
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 606, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 614, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfrol	value:8
h	def:D	type:int	value:7
p	def:U	type:proc	value:5

rec call: 
5

# using the miniOO:
find var:y
cmd: 0:	var

y	def:U	type:nil	value:0

find num:	1
num:1:	1

cmd: 1:	num
cmd: 0:	var

in handle lesser: not defined:	0
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 2	op: <	0	1

find num:	1
num:3:	1
num:1:	1

cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p = cmd:3;
p	cmd: 3	in proc now.
cmd: 4	left: p	equals cmd:3

find var:p
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

find var:y
cmd: 6:	var
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

find num:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 7:	num
cmd: 6:	var
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

not found all the parameter.
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 8	op: -	6	7
cmd: 2	op: <	0	1

5(8)
ready to runnil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmdl	value:8
h	def:D	type:int	value:7
p	def:U	type:proc	value:5

rec call: 
5

# using the miniOO:
find var:y
cmd: 0:	var

y	def:U	type:nil	value:0

find num:	1
num:1:	1

cmd: 1:	num
cmd: 0:	var

in handle lesser: not defined:	0
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 2	op: <	0	1

find num:	1
num:3:	1
num:1:	1

cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p = cmd:3;
p	cmd: 3	in proc now.
cmd: 4	left: p	equals cmd:3

find var:p
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

find var:y
cmd: 6:	var
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

find num:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 7:	num
cmd: 6:	var
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	vamake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 343, characters 4-6:
Error: Syntax error: operator expected.
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 342, characters 6-8:
Error: Syntax error: ')' expected
File "calculatorYACC.mly", line 338, characters 27-28:
Error: This '(' might be unmatched
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 340, characters 6-14:
Error: Unbound value handlCmd
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 340, characters 6-14:
Error: Unbound value handlCmd
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 616, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 624, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 616, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 624, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	1
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
ready (8)
ready to runnil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to runp	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9 with paraid:8
para name:y	run cmd:10
binary operation:	6	-	7
num:	1
var:	1
1	-	1
num:	1
var:	1
num:14:	0
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

y	def:T	type:nil	value:14
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 15:	true
cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	(8)
ready to runnil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
48 states, 2667 transitions, table size 10956 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	1
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
ready (8)
ready to runnil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to runp	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9 with paraid:8
para name:y	run cmd:10
binary operation:	6	-	7
num:	1
var:	1
1	-	1
num:	1
var:	1
num:14:	0
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

y	def:T	type:nil	value:14
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 15:	true
cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

15
cond	true:	4
assignment:	p = cmd: 3
p	def:D	type:int	value:1
y	def:T	type:nil	value:14
p	def:U	type:nil	value:0

rec call: 
1

# the end.
bash-3.2$ make
makefile:19: *** missing separator.  Stop.
bash-3.2$ make
makefile:19: *** missing separator.  Stop.
bash-3.2$ make delete
makefile:19: *** missing separator.  Stop.
bash-3.2$ make
makefile:19: *** missing separator.  Stop.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 665, characters 16-92:
Error: This expression has type unit
       This is not a function; it cannot be applied.
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here ismake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 statmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	1
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
ready (8)
ready to runnil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to runp	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9 with paraid:8
para name:y	run cmd:10
binary operation:	6	-	7
num:	1
var:	1
1	-	1
num:	1
var:	1
num:14:	0
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

y	def:T	type:nil	value:14
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 15:	true
cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

15
cond	true:	4
assignment:	p = cmd: 3
p	def:D	type:int	value:1
y	def:T	type:nil	value:14
p	def:U	type:nil	value:0

rec call: 
1

“# using the miniOO part 3:”
/bin/sh: -c: line 0: syntax error near unexpected token `x'
/bin/sh: -c: line 0: `echo “var x; malloc(x);x.C = 0;x.F = proc y:if y < 1 then x.R = x.C else x.F(y - 1);x.F(2)” | ./calculator'
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	1
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
ready (8)
ready to runnil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to runp	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9 with paraid:8
para name:y	run cmd:10
binary operation:	6	-	7
num:	1
var:	1
1	-	1
num:	1
var:	1
num:14:	0
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

y	def:T	type:nil	value:14
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 15:	true
cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	(8)
ready to runnil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to runp	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9 with paraid:8
para name:y	run cmd:10
binary operation:	6	-	7
num:	1
var:	1
1	-	1
num:	1
var:	1
num:14:	0
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

y	def:T	type:nil	value:14
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 15:	true
cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

15
cond	true:	4
assignment:	p = cmd: 3
p	def:D	type:int	value:1
y	def:T	type:nil	value:14
p	def:U	type:nil	value:0

rec call: 
1

# using the miniOO part 3:
MALLOC x
cmd: 0:	obj

find field:x.C
cmd: 1:	field
cmd: 0:	obj

x.C	def:U	type:nil	value:0

Syntax error ...
find num:	0
num:2:	0

cmd: 2:	num
cmd: 1:	field
cmd: 0:	obj

Syntax error ...
find field:x.F
cmd: 3:	field
cmd: 2:	num
cmd: 1:	field
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.C	def:U	type:nil	value:0

Syntax error ...
find var:y
cmd: 4:	var
cmd: 3:	field
cmd: 2:	num
cmd: 1:	field
cmd: 0:	obj

y	def:U	type:nil	value:0
x.F	def:U	type:nil	valuy	def:U	type:nil	value:0
x.F	def:U	type:nil	value:0
x.C	def:U	type:nil	value:0

not found all the parameter.
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 8:	field
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	field
cmd: 2:	num
cmd: 1:	field
cmd: 0:	obj

cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 8:	field
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	field
cmd: 2:	num
cmd: 1:	field
cmd: 0:	obj

cmd: 12	op: -	10	11
cmd: 6	op: <	4	5

9(12)
ready to runnil	cmd: 9	12
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 8:	field
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	field
cmd: 2:	num
cmd: 1:	field
cmd: 0:	obj

rec call: 
13

find field:x.F
cmd: 14:	field
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 8:	field
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	field
cmd: 2:	num
cmd: 1:	field
cmd: 0:	obj

x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.F	def:U	type:nil	value:0
x.C	def:U	type:nil	value:0

find num:	2
num:15:	2
num:11:	1
num:5:	1
num:2:	0

cmd: 15:	num
cmd: 14:	field
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 8:	field
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	field
cmd: 2:	num
cmd: 1:	field
cmd: 0:	obj

14(15)
ready to runnil	cmd: 14	15
cmd: 16:	rec
cmd: 15:	num
cmd: 14:	field
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 8:	field
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	field
cmd: 2:	num
cmd: 1:	field
cmd: 0:	obj

rec call: 
16

# the end.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
4 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

not found all the parameter.
num:4:	1
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	1
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
ready 5(8)
ready to run:nil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to run:p	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9 with paraid:8
para name:y	run cmd:10
binary operation:	6	-	7
num:	1
var:	1
1	-	1
num:	1
var:	1
num:14:	0
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

y	def:T	type:nil	value:14
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 15:	true
cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 15(8)
ready to run:nil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to run:p	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9 with paraid:8
para name:y	run cmd:10
binary operation:	6	-	7
num:	1
var:	1
1	-	1
num:	1
var:	1
num:14:	0
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

y	def:T	type:nil	value:14
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 15:	true
cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

15
cond	true:	4
assignment:	p = cmd: 3
p	def:D	type:int	value:1
y	def:T	type:nil	value:14
p	def:U	type:nil	value:0

rec call: 
1

# using the miniOO part 3:
MALLOC x
cmd: 0:	obj

find field:x.C
cmd: 1:	field
cmd: 0:	obj

x.C	def:U	type:nil	value:0

Syntax error ...
find num:	0
num:2:	0

cmd: 2:	num
cmd: 1:	field
cmd: 0:	obj

Syntax error ...
find field:x.F
cmd: 3:	field
cmd: 2:	num
cmd: 1:	field
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.C	def:U	type:nil	value:0

Syntax error ...
find var:y
cmd: 4:	var
cmd: 3:	field
cmd: 2:	num
cmd: 1:	field
cmd: 0:	obj

y	def:U	type:nil	value:0
x.F	def:U	type:nil	v0
y	def:U	type:nil	value:0
x.F	def:U	type:nil	value:0
x.C	def:U	type:nil	value:0

not found all the parameter.
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 8:	field
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	field
cmd: 2:	num
cmd: 1:	field
cmd: 0:	obj

cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 8:	field
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	field
cmd: 2:	num
cmd: 1:	field
cmd: 0:	obj

cmd: 12	op: -	10	11
cmd: 6	op: <	4	5

9(12)
ready to run:nil	cmd: 9	12
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 8:	field
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	field
cmd: 2:	num
cmd: 1:	field
cmd: 0:	obj

rec call: 
13

find field:x.F
cmd: 14:	field
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 8:	field
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	field
cmd: 2:	num
cmd: 1:	field
cmd: 0:	obj

x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.F	def:U	type:nil	value:0
x.C	def:U	type:nil	value:0

find num:	2
num:15:	2
num:11:	1
num:5:	1
num:2:	0

cmd: 15:	num
cmd: 14:	field
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 8:	field
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	field
cmd: 2:	num
cmd: 1:	field
cmd: 0:	obj

14(15)
ready to run:nil	cmd: 14	15
cmd: 16:	rec
cmd: 15:	num
cmd: 14:	field
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 8:	field
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	f0
y	def:U	type:nil	value:0
x.F	def:U	type:nil	value:0
x.C	def:U	type:nil	value:0

nomake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 675, characters 28-32:
Error: Syntax error
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 696, characters 27-31:
Error: Syntax error
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 682, characters 51-52:
Error: Unbound value t
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 723, characters 12-76:
Error: This expression has type int but an expression was expected of type
         unit
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 723, characters 12-76:
Error: This expression has type int but an expression was expected of type
         unit
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:0

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

not found all the parameter.
num:4:	0
num:0:	1

cmd: 4:	num
make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:0

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

not found all the parameter.
num:4:	0
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	0
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	0
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
ready 5(8)
ready to run:nil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to run:p	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9 with paraid:8
para name:y	run cmd:10
binary operation:	6	-	7
num:	1
var:	1
1	-	1
num:	1
var:	1
num:14:	0
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

y	def:T	type:nil	value:14
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 15:	true
cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 15(8)
ready to run:nil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to run:p	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9 with paraid:8
para name:y	run cmd:10
binary operation:	6	-	7
num:	1
var:	1
1	-	1
num:	1
var:	1
num:14:	0
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

y	def:T	type:nil	value:14
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 15:	true
cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

15
cond	true:	4
assignment:	p = cmd: 3
p	def:D	type:int	value:1
y	def:T	type:nil	value:14
p	def:U	type:nil	value:0

rec call: 
1

# using the miniOO part 3:
MALLOC x
cmd: 0:	obj

find num:	0
num:1:	0

cmd: 1:	num
cmd: 0:	obj

x.C= cmd:1 as a intcmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.C	def:U	type:nil	value:0

find var:y
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:U	type:nil	value:0
x.C	def:D	type:int	value:1

find num:	1
num:4:	1
num:1:	0

cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

in handle lesser: not defined:	3
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	fie 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12	op: -	10	11
cmd: 5	op: <	3	4

9(12)
ready to run:nil	cmd: 9	12
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
13

if else
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc y:
x.F= cmd:14 as a proccmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:1

15	= cmd:14
now in declare proc.
proc: x.F	para: y	cmd: 14
find field:x.F
proc: x.F	para: y	cmd: 14
find num:	2
num:17:	2
num:11:	1
num:4:	1
num:1:	0

cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

14(17)
ready to run:x.F	cmd: 14	17
para: y=17
run cmd: 14
binary operation:	3	<	4
num:	1
var:	2
2	<	1
num:	1
var:	2
cmd: 18:	false
cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	v 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12	op: -	10	11
cmd: 5	op: <	3	4

9(12)
ready to run:nil	cmd: 9	12
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
13

if else
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc y:
x.F= cmd:14 as a proccmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:1

15	= cmd:14
now in declare proc.
proc: x.F	para: y	cmd: 14
find field:x.F
proc: x.F	para: y	cmd: 14
find num:	2
num:17:	2
num:11:	1
num:4:	1
num:1:	0

cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

14(17)
ready to run:x.F	cmd: 14	17
para: y=17
run cmd: 14
binary operation:	3	<	4
num:	1
var:	2
2	<	1
num:	1
var:	2
cmd: 18:	false
cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

18
cond	false:	13
handleCmd:13 with paraid:12
para name:y	run cmd:14
binary operation:	10	-	11
num:	1
var:	2
2	-	1
num:	1
var:	2
num:19:	1
num:17:	2
num:11:	1
num:4:	1
num:1:	0

cmd: 19:	num
cmd: 18:	false
cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
/bin/sh: -c: line 0: unexpected EOF while looking for matching `"'
/bin/sh: -c: line 1: syntax error: unexpected end of file
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:0

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

not found all the parameter.
num:4:	0
num:0:	1

cmd: 4make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:0

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

not found all the parameter.
num:4:	0
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	0
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	0
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)	op: <	0	1

5(8)
ready to run:nil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to run:p	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9 with paraid:8
para name:y	run cmd:10
binary operation:	6	-	7
num:	1
var:	1
1	-	1
num:	1
var:	1
num:14:	0
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

y	def:T	type:nil	value:14
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 15:	true
cmd: 14:	num
cmd: 13:	false
cmd: 1	op: <	0	1

5(8)
ready to run:nil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to run:p	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9 with paraid:8
para name:y	run cmd:10
binary operation:	6	-	7
num:	1
var:	1
1	-	1
num:	1
var:	1
num:14:	0
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

y	def:T	type:nil	value:14
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 15:	true
cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

15
cond	true:	4
assignment:	p = cmd: 3
p	def:D	type:int	value:1
y	def:T	type:nil	value:14
p	def:U	type:nil	value:0

rec call: 
1

# using the miniOO part 3:
MALLOC x
cmd: 0:	obj

find num:	0
num:1:	0

cmd: 1:	num
cmd: 0:	obj

x.C= cmd:1 as a intcmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.C	def:U	type:nil	value:0

find var:y
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:U	type:nil	value:0
x.C	def:D	type:int	value:1

find num:	1
num:4:	1
num:1:	0

cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

in handle lesser: not defined:	3
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	va: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12	op: -	10	11
cmd: 5	op: <	3	4

9(12)
ready to run:nil	cmd: 9	12
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
13

if else
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc y:
x.F= cmd:14 as a proccmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:1

15	= cmd:14
now in declare proc.
proc: x.F	para: y	cmd: 14
find field:x.F
proc: x.F	para: y	cmd: 14
find num:	2
num:17:	2
num:11:	1
num:4:	1
num:1:	0

cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

14(17)
ready to run:x.F	cmd: 14	17
para: y=17
run cmd: 14
binary operation:	3	<	4
num:	1
var:	2
2	<	1
num:	1
var:	2
cmd: 18:	false
cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12	op: -	10	11
cmd: 5	op: <	3	4

9(12)
ready to run:nil	cmd: 9	12
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
13

if else
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc y:
x.F= cmd:14 as a proccmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:1

15	= cmd:14
now in declare proc.
proc: x.F	para: y	cmd: 14
find field:x.F
proc: x.F	para: y	cmd: 14
find num:	2
num:17:	2
num:11:	1
num:4:	1
num:1:	0

cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

14(17)
ready to run:x.F	cmd: 14	17
para: y=17
run cmd: 14
binary operation:	3	<	4
num:	1
var:	2
2	<	1
num:	1
var:	2
cmd: 18:	false
cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

18
cond	false:	13
handleCmd:13 with paraid:12
para name:y	run cmd:14
binary operation:	10	-	11
num:	1
var:	2
2	-	1
num:	1
var:	2
num:19:	1
num:17:	2
num:11:	1
num:4:	1
num:1:	0

cmd: 19:	num
cmd: 18:	false
cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:0

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

not found all the parameter.
num:4:	0
num:0:	1

cmd: 4make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:0

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

not found all the parameter.
num:4:	0
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	0
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:2
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	0
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)	op: <	0	1

5(8)
ready to run:nil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to run:p	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9 with paraid:8
para name:y	run cmd:10
binary operation:	6	-	7
num:	1
var:	1
1	-	1
num:	1
var:	1
num:14:	0
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

y	def:T	type:nil	value:14
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 15:	true
cmd: 14:	num
cmd: 13:	false
cmd: 1	op: <	0	1

5(8)
ready to run:nil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to run:p	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9 with paraid:8
para name:y	run cmd:10
binary operation:	6	-	7
num:	1
var:	1
1	-	1
num:	1
var:	1
num:14:	0
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

y	def:T	type:nil	value:14
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 15:	true
cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

15
cond	true:	4
assignment:	p = cmd: 3
p	def:D	type:int	value:1
y	def:T	type:nil	value:14
p	def:U	type:nil	value:0

rec call: 
1

# using the miniOO part 3:
MALLOC x
cmd: 0:	obj

find num:	0
num:1:	0

cmd: 1:	num
cmd: 0:	obj

x.C= cmd:1 as a intcmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.C	def:U	type:nil	value:0

find var:y
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

find num:	1
num:4:	1
num:1:	0

cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

in handle lesser: not defined:	3
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	va: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12	op: -	10	11
cmd: 5	op: <	3	4

9(12)
ready to run:nil	cmd: 9	12
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
13

if else
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc y:
x.F= cmd:14 as a proccmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

15	= cmd:14
now in declare proc.
proc: x.F	para: y	cmd: 14
find field:x.F
proc: x.F	para: y	cmd: 14
find num:	2
num:17:	2
num:11:	1
num:4:	1
num:1:	0

cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

14(17)
ready to run:x.F	cmd: 14	17
para: y=17
run cmd: 14
binary operation:	3	<	4
num:	1
var:	2
2	<	1
num:	1
var:	2
cmd: 18:	false
cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

18
cond	false:	13
handleCmd:13 with paraid:12
para name:y	run cmd:14
binary operation:	10	-	11
num:	1
var:	2
2	-	1
num:	1
var:	2
num:19:	1
num:17:	2
num:11:	1
num:4:	1
num:1:	0

cmd: 19:	num
cmd: 18:	false
cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:T	type:nil	value:19
x.F	def:U	type:proc	value:14
x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

binary operation:	3	<	4
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 20:	false
cmd: 19:	num
cmd: 18:	false
cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

20
cond	false:	13
handleCmd:13 with paraid:12
para name:y	run cmd:14
binary operation:	10	-	11
num:	1
var:	1
1	-	1
num:	1
var:	1
num:21:	0
num:19:	1
num:17:	2
num:11:	1
num:4:	1
num:1:	0

cmd: 21:	num
cmd: 20:	false
cmd: 19:	num
cmd: 18:	false
cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:T	type:nil	value:21
x.F	def:U	type:proc	value:14
x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

binary operation:	3	<	4
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 22:	true
cmd: 21:	num
cmd: 20:	false
cmd: 19:	num
cmd: 18:	false
cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

22
cond	true:	8
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:0

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

not found all the parameter.
num:4:	0
num:0:	1

cmd: 4make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:0

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

not found all the parameter.
num:4:	0
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	0
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	0
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)	op: <	0	1

5(8)
ready to run:nil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to run:p	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9 with paraid:8
para name:y	run cmd:10
binary operation:	6	-	7
num:	1
var:	1
1	-	1
num:	1
var:	1
num:14:	0
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

y	def:T	type:nil	value:14
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 15:	true
cmd: 14:	num
cmd: 13:	false
cmd: 1	op: <	0	1

5(8)
ready to run:nil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to run:p	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9 with paraid:8
para name:y	run cmd:10
binary operation:	6	-	7
num:	1
var:	1
1	-	1
num:	1
var:	1
num:14:	0
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

y	def:T	type:nil	value:14
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 15:	true
cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

15
cond	true:	4
assignment:	p = cmd: 3
p	def:D	type:int	value:1
y	def:T	type:nil	value:14
p	def:U	type:nil	value:0

rec call: 
1

# using the miniOO part 3:
MALLOC x
cmd: 0:	obj

find num:	0
num:1:	0

cmd: 1:	num
cmd: 0:	obj

x.C= cmd:1 as a intcmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.C	def:U	type:nil	value:0

find var:y
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:U	type:nil	value:0
x.C	def:D	type:int	value:1

find num:	1
num:4:	1
num:1:	0

cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

in handle lesser: not defined:	3
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	va: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12	op: -	10	11
cmd: 5	op: <	3	4

9(12)
ready to run:nil	cmd: 9	12
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
13

if else
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc y:
x.F= cmd:14 as a proccmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:1

15	= cmd:14
now in declare proc.
proc: x.F	para: y	cmd: 14
find field:x.F
proc: x.F	para: y	cmd: 14
find num:	2
num:17:	2
num:11:	1
num:4:	1
num:1:	0

cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

14(17)
ready to run:x.F	cmd: 14	17
para: y=17
run cmd: 14
binary operation:	3	<	4
num:	1
var:	2
2	<	1
num:	1
var:	2
cmd: 18:	false
cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12	op: -	10	11
cmd: 5	op: <	3	4

9(12)
ready to run:nil	cmd: 9	12
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
13

if else
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc y:
x.F= cmd:14 as a proccmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:1

15	= cmd:14
now in declare proc.
proc: x.F	para: y	cmd: 14
find field:x.F
proc: x.F	para: y	cmd: 14
find num:	2
num:17:	2
num:11:	1
num:4:	1
num:1:	0

cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

14(17)
ready to run:x.F	cmd: 14	17
para: y=17
run cmd: 14
binary operation:	3	<	4
num:	1
var:	2
2	<	1
num:	1
var:	2
cmd: 18:	false
cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

18
cond	false:	13
handleCmd:13 with paraid:12
para name:y	run cmd:14
binary operation:	10	-	11
num:	1
var:	2
2	-	1
num:	1
var:	2
num:19:	1
num:17:	2
num:11:	1
num:4:	1
num:1:	0

cmd: 19:	num
cmd: 18:	false
cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:T	type:nil	value:19
x.F	def:U	type:proc	value:14
x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
x.C	def:D	type:int	value:1

binary operation:	3	<	4
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 20:	false
cmd: 19:	num
cmd: 18:	false
cmd: 17:	num
cmd: 16:	procatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:0

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

not found all the parameter.
num:4:	0
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in procatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	nummake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:0

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

not found all the parameter.
num:4:	0
num:0:	1

cmd: 4make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 617, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 625, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	nummake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 619, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 627, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:0

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

not found all the parameter.
2 is not assigned.
num:4:	0make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 619, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 627, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:0

make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 618, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 626, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:0

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

not found all the parameter.
2 is not assigned.
cmd: 2:	make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 618, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 626, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:inmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 619, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 627, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:0

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

not found all the parameter.
2 is not assigned.
num:4:	0
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

1 is already assigned.
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	0
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:7
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	0
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
ready to run:p	cmd: 5	8
para: y=8
run cmd: 5
assignment:	r = cmd: 3
binary operation:	1	+	4
var:	4
4	+	num:	0
0
num:	0
var:	4
num:9:	4
num:8:	4
num:7:	2
num:4:	0
num:0:	1

cmd: 9:	num
cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

9
r	def:D	type:int	value:9
y	def:T	type:nil	value:8
h	def:D	type:int	value:7
p	def:U	type:proc	value:5

rec call: 
4

# the end.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 462, characters 4-16:
Error: This function has type string -> unit
       It is applied to too many arguments; maybe you forgot a `;'.
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 622, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 630, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:0

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

nilnot found all the parameter.
int2 is  assigned.
num:4make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 622, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 630, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:0

find var:ymake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 622, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 630, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:0

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

nil
not found all the parameter.
int
2 is  assigned.
nmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 622, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 630, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:0

find var:y
cmd:make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 622, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 630, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:0

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

y	def:U	type:nil	value:0
h	def:U	type:int	value:0

nil
not found all the parameter.
int
2 is  assigned.
nmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 622, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 630, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:0

find var:y
cmd:make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 622, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 630, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
int
2 is  assigned.
num:4:	1
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

nil
1 is not already assigned.
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	1
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:2
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

5(8)
ready to run:p	cmd: 5	8
para: y=8
run cmd: 5
assignment:	r = cmd: 3
binary operation:	1	+	4
var:	4
4	+	num:	1
1
num:	1
var:	4
num:9:	5
num:8:	4
num:7:	2
num:4:	1
num:0:	1

cmd: 9:	num
cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

9
r	def:D	type:int	value:9
y	def:T	type:nil	value:8
h	def:D	type:int	value:2
p	def:U	type:proc	value:5

rec call: 
5

# the end.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 622, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 630, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
int
2 is  assigned.
nmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 622, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 630, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
int
2 is  assigned.
num:4:	1
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

nil
1 is not already assigned.
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	1
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:2
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binopvar
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 8	op: -	6	7
cmd: 2	op: <	0	1

5(8)
ready to run:nil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to run:p	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9 with paraid:8
para name:y	run cmd:10
binary operation:	6	-	7
num:	1
var:	1
1	-	1
num:	1
var:	1
num:14:	0
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

y	def:T	type:nil	value:14
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 8	op: -	6	7
cmd: 2	op: <	0	1

5(8)
ready to run:nil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to run:p	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9 with paraid:8
para name:y	run cmd:10
binary operation:	6	-	7
num:	1
var:	1
1	-	1
num:	1
var:	1
num:14:	0
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

y	def:T	type:nil	value:14
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 15:	true
cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

15
cond	true:	4
assignment:	p = cmd: 3
p	def:D	type:int	value:1
y	def:T	type:nil	value:14
p	def:U	type:nil	value:0

rec call: 
1

# using the miniOO part 3:
MALLOC x
cmd: 0:	obj

find num:	0
num:1:	0

cmd: 1:	num
cmd: 0:	obj

x.C= cmd:1 as a intcmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.C	def:U	type:nil	value:0

find var:y
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

find num:	1
num:4:	1
num:1:	0

cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cm
cmd: 0:	obj

cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12	op: -	10	11
cmd: 5	op: <	3	4

9(12)
ready to run:nil	cmd: 9	12
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
13

if else
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc y:
x.F= cmd:14 as a proccmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

15	= cmd:14
now in declare proc.
proc: x.F	para: y	cmd: 14
find field:x.F
proc: x.F	para: y	cmd: 14
find num:	2
num:17:	2
num:11:	1
num:4:	1
num:1:	0

cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

14(17)
ready to run:x.F	cmd: 14	17
para: y=17
run cmd: 14
binary operation:	3	<	4
num:	1
var:	2
2	<	1
num:	1
var:	2
cmd: 18:	false
cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd:
cmd: 0:	obj

cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12	op: -	10	11
cmd: 5	op: <	3	4

9(12)
ready to run:nil	cmd: 9	12
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
13

if else
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc y:
x.F= cmd:14 as a proccmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

15	= cmd:14
now in declare proc.
proc: x.F	para: y	cmd: 14
find field:x.F
proc: x.F	para: y	cmd: 14
find num:	2
num:17:	2
num:11:	1
num:4:	1
num:1:	0

cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

14(17)
ready to run:x.F	cmd: 14	17
para: y=17
run cmd: 14
binary operation:	3	<	4
num:	1
var:	2
2	<	1
num:	1
var:	2
cmd: 18:	false
cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

18
cond	false:	13
handleCmd:13 with paraid:12
para name:y	run cmd:14
binary operation:	10	-	11
num:	1
var:	2
2	-	1
num:	1
var:	2
num:19:	1
num:17:	2
num:11:	1
num:4:	1
num:1:	0

cmd: 19:	num
cmd: 18:	false
cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 622, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 630, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
int
2 is  assigned.
nmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 622, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 630, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
int
2 is  assigned.
num:4:	1
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

nil
1 is not already assigned.
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	1
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:2
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binopvar
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 8	op: -	6	7
cmd: 2	op: <	0	1

5(8)
ready to run:nil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to run:p	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9 with paraid:8
para name:y	run cmd:10
binary operation:	6	-	7
num:	1
var:	1
1	-	1
num:	1
var:	1
num:14:	0
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

y	def:T	type:nil	value:14
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 8	op: -	6	7
cmd: 2	op: <	0	1

5(8)
ready to run:nil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to run:p	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9 with paraid:8
para name:y	run cmd:10
binary operation:	6	-	7
num:	1
var:	1
1	-	1
num:	1
var:	1
num:14:	0
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

y	def:T	type:nil	value:14
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 15:	true
cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

15
cond	true:	4
assignment:	p = cmd: 3
p	def:D	type:int	value:1
y	def:T	type:nil	value:14
p	def:U	type:nil	value:0

rec call: 
1

# using the miniOO part 3:
MALLOC x
cmd: 0:	obj

find num:	0
num:1:	0

cmd: 1:	num
cmd: 0:	obj

x.C= cmd:1 as a int
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.C	def:U	type:nil	value:0

x.C	def:D	type:int	value:0

find var:y
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

find num:	1
num:4:	1
num:1:	0

cmd: 4:	num3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12	op: -	10	11
cmd: 5	op: <	3	4

9(12)
ready to run:nil	cmd: 9	12
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
13

if else
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc y:
x.F= cmd:14 as a proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

15	= cmd:14
now in declare proc.
proc: x.F	para: y	cmd: 14
find field:x.F
proc: x.F	para: y	cmd: 14
find num:	2
num:17:	2
num:11:	1
num:4:	1
num:1:	0

cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

14(17)
ready to run:x.F	cmd: 14	17
para: y=17
run cmd: 14
binary operation:	3	<	4
num:	1
var:	2
2	<	1
num:	1
var:	2
cmd: 18:	false
cmd: 17:	num3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12	op: -	10	11
cmd: 5	op: <	3	4

9(12)
ready to run:nil	cmd: 9	12
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
13

if else
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc y:
x.F= cmd:14 as a proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

15	= cmd:14
now in declare proc.
proc: x.F	para: y	cmd: 14
find field:x.F
proc: x.F	para: y	cmd: 14
find num:	2
num:17:	2
num:11:	1
num:4:	1
num:1:	0

cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

14(17)
ready to run:x.F	cmd: 14	17
para: y=17
run cmd: 14
binary operation:	3	<	4
num:	1
var:	2
2	<	1
num:	1
var:	2
cmd: 18:	false
cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

18
cond	false:	13
handleCmd:13 with paraid:12
para name:y	run cmd:14
binary operation:	10	-	11
num:	1
var:	2
2	-	1
num:	1
var:	2
num:19:	1
num:17:	2
num:11:	1
num:4:	1
num:1:	0

cmd: 19:	num
cmd: 18:	false
cmd: 17:	num
cmd: 16:	proc
cmd: 15:	field
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 10:	var
cmd: 11:	num
cmd: 9:	field
cmd: 7:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 622, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 630, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
int
2 is  assigned.
nmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 622, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 630, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
int
2 is  assigned.
num:4:	1
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

nil
1 is not already assigned.
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	1
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:2
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binopvar
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 8	op: -	6	7
cmd: 2	op: <	0	1

5(8)
ready to run:nil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to run:p	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9 with paraid:8
para name:y	run cmd:10
binary operation:	6	-	7
num:	1
var:	1
1	-	1
num:	1
var:	1
num:14:	0
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

y	def:T	type:nil	value:14
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 8	op: -	6	7
cmd: 2	op: <	0	1

5(8)
ready to run:nil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to run:p	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9 with paraid:8
para name:y	run cmd:10
binary operation:	6	-	7
num:	1
var:	1
1	-	1
num:	1
var:	1
num:14:	0
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

y	def:T	type:nil	value:14
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 15:	true
cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

15
cond	true:	4
assignment:	p = cmd: 3
p	def:D	type:int	value:1
y	def:T	type:nil	value:14
p	def:U	type:nil	value:0

rec call: 
1

# using the miniOO part 3:
MALLOC x
cmd: 0:	obj

find num:	0
num:1:	0

cmd: 1:	num
cmd: 0:	obj

x.C= cmd:1 as a int
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.C	def:U	type:nil	value:0

x.C	def:D	type:int	value:0

find var:y
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

find num:	1
num:4:	1
num:1:	0

cmd: 4:	num: 5	op: <	3	4

8(11)
ready to run:nil	cmd: 8	11
cmd: 12:	rec
cmd: 11:	binop
cmd: 9:	var
cmd: 10:	num
cmd: 8:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
12

if else
cmd: 13:	cond
cmd: 12:	rec
cmd: 11:	binop
cmd: 9:	var
cmd: 10:	num
cmd: 8:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc y:
x.F= cmd:13 as a proc
-1	= cmd:13
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 622, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 630, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
int
2 is  assigned.
nmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 622, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 630, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
int
2 is  assigned.
num:4:	1
num:0:	1

cmd: 4:	num
cmd: 2:	var
cmd: 1:	var
cmd: 0:	num

nil
1 is not already assigned.
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

cmd: 3	op: +	1	4

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 5	left: r	equals cmd:3

proc y:
p = cmd:5;
p	cmd: 5	in proc now.
now in declare proc.
proc: p	para: y	cmd: 5
find num:	2
num:7:	2
num:4:	1
num:0:	1

cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binop
cmd: 1:	var
cmd: 4:	num
cmd: 2:	var
cmd: 0:	num

h = cmd:7;
h	def:D	type:int	value:2
p	def:U	type:proc	value:5
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 5
find num:	4
num:8:	4
num:7:	2
num:4:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	proc
cmd: 5:	ass
cmd: 3:	binopvar
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 8	op: -	6	7
cmd: 2	op: <	0	1

5(8)
ready to run:nil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to run:p	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9 with paraid:8
para name:y	run cmd:10
binary operation:	6	-	7
num:	1
var:	1
1	-	1
num:	1
var:	1
num:14:	0
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

y	def:T	type:nil	value:14
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 8	op: -	6	7
cmd: 2	op: <	0	1

5(8)
ready to run:nil	cmd: 5	8
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

rec call: 
9

if else
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

proc y:
p = cmd:10;
p	cmd: 10	in proc now.
now in declare proc.
proc: p	para: y	cmd: 10
find var:p
proc: p	para: y	cmd: 10
find num:	1
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

10(12)
ready to run:p	cmd: 10	12
para: y=12
run cmd: 10
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

13
cond	false:	9
handleCmd:9 with paraid:8
para name:y	run cmd:10
binary operation:	6	-	7
num:	1
var:	1
1	-	1
num:	1
var:	1
num:14:	0
num:12:	1
num:7:	1
num:3:	1
num:1:	1

cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

y	def:T	type:nil	value:14
p	def:U	type:proc	value:10
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 15:	true
cmd: 14:	num
cmd: 13:	false
cmd: 12:	num
cmd: 11:	proc
cmd: 10:	cond
cmd: 9:	rec
cmd: 8:	binop
cmd: 6:	var
cmd: 7:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

15
cond	true:	4
assignment:	p = cmd: 3
p	def:D	type:int	value:1
y	def:T	type:nil	value:14
p	def:U	type:nil	value:0

rec call: 
1

# using the miniOO part 3:
MALLOC x
cmd: 0:	obj

find num:	0
num:1:	0

cmd: 1:	num
cmd: 0:	obj

x.C= cmd:1 as a int
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.C	def:U	type:nil	value:0

x.C	def:D	type:int	value:0

find var:y
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

find num:	1
num:4:	1
num:1:	0

cmd: 4:	num	op: <	3	4

8(11)
ready to run:nil	cmd: 8	11
cmd: 12:	rec
cmd: 11:	binop
cmd: 9:	var
cmd: 10:	num
cmd: 8:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
12

if else
cmd: 13:	cond
cmd: 12:	rec
cmd: 11:	binop
cmd: 9:	var
cmd: 10:	num
cmd: 8:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc y:
x.F= cmd:13 as a proc
8	= cmd:13
now in declare proc.
proc: x.F	para: y	cmd: 13
find field:x.F
proc: x.F	para: y	cmd: 13
find num:	2
num:15:	2
num:10:	1
num:4:	1
num:1:	0

cmd: 15:	num
cmd: 14:	proc
cmd: 13:	cond
cmd: 12:	rec
cmd: 11:	binop
cmd: 9:	var
cmd: 10:	num
cmd: 8:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

13(15)
ready to run:x.F	cmd: 13	15
para: y=15
run cmd: 13
binary operation:	3	<	4
num:	1
var:	2
2	<	1
num:	1
var:	2
cmd: 16:	false
cmd: 15:	num
cmd: 14:	proc
cmd: 13:	cond
cmd: 12:	rec
cmd: 11:	binop
cmd: 9:	var
cmd: 10:	num
cmd: 8:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

16
cond	false:	12
handleCmd:12 with paraid:11
para name:y	run cmd:13
binary operation:	9	-	10
num:	1
var:	2
2	-	1
num:	1
var:	2
num:17:	1
num:15:	2
num:10:	1
num:4:	1
num:1:	0

cmd: 17:	num
cmd: 16:	false
cmd: 15:	num
cmd: 14:	proc
cmd: 13:	cond
cmd: 12:	rec
cmd: 11:	binop
cmd: 9:	var
cmd: 10:	num
cmd: 8:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:	op: <	3	4

8(11)
ready to run:nil	cmd: 8	11
cmd: 12:	rec
cmd: 11:	binop
cmd: 9:	var
cmd: 10:	num
cmd: 8:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
12

if else
cmd: 13:	cond
cmd: 12:	rec
cmd: 11:	binop
cmd: 9:	var
cmd: 10:	num
cmd: 8:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc y:
x.F= cmd:13 as a proc
8	= cmd:13
now in declare proc.
proc: x.F	para: y	cmd: 13
find field:x.F
proc: x.F	para: y	cmd: 13
find num:	2
num:15:	2
num:10:	1
num:4:	1
num:1:	0

cmd: 15:	num
cmd: 14:	proc
cmd: 13:	cond
cmd: 12:	rec
cmd: 11:	binop
cmd: 9:	var
cmd: 10:	num
cmd: 8:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

13(15)
ready to run:x.F	cmd: 13	15
para: y=15
run cmd: 13
binary operation:	3	<	4
num:	1
var:	2
2	<	1
num:	1
var:	2
cmd: 16:	false
cmd: 15:	num
cmd: 14:	proc
cmd: 13:	cond
cmd: 12:	rec
cmd: 11:	binop
cmd: 9:	var
cmd: 10:	num
cmd: 8:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

16
cond	false:	12
handleCmd:12 with paraid:11
para name:y	run cmd:13
binary operation:	9	-	10
num:	1
var:	2
2	-	1
num:	1
var:	2
num:17:	1
num:15:	2
num:10:	1
num:4:	1
num:1:	0

cmd: 17:	num
cmd: 16:	false
cmd: 15:	num
cmd: 14:	proc
cmd: 13:	cond
cmd: 12:	rec
cmd: 11:	binop
cmd: 9:	var
cmd: 10:	num
cmdmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 116, characters 43-80:
Error: This expression has type (int * string) list -> int
       but an expression was expected of type int
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 116, characters 43-82:
Error: This expression has type (int * string) list -> int
       but an expression was expected of type int
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 116, characters 43-82:
Error: This expression has type (int * string) list -> int
       but an expression was expected of type int
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 633, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 641, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
not in cmd list.
nil
1 is not already assigned.
cmd: 1:	var
cmd: 0:	num

cmd: 2:	binop
cmd: 1:	var
cmd: 0:	nummake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 633, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 641, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
not in cmd list.
nil
1 is not already assigned.
cmd: 1:	var
cmd: 0:	num

cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

cmd: 2	op: +	1	-1

r = cmd:2;
r	cmd: 2	in proc now.
cmd: 3	left: r	equals cmd:2

proc y:
p = cmd:3;
p	cmd: 3	in proc now.
now in declare proc.
proc: p	para: y	cmd: 3
find num:	2
num:5:	2
num:0:	1

cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

h = cmd:5;
h	def:D	type:int	value:2
p	def:U	type:proc	value:3
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 3
find num:	4
num:6:	4
num:5:	2
num:0:	1

cmd: 6:	num
cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

3(6)
ready to run:p	cmd: 3	6
para: y=6
run cmd: 3
assignment:	r = cmd: 2
binary operation:	1	+	-1
var:	4
4	+	varid not in cmd list.
-1
varid not in cmd list.
var:	4
num:7:	3
num:6:	4
num:5:	2
num:0:	1

cmd: 7:	num
cmd: 6:	nume proc.
proc: p	para: y	cmd: 9
find var:p
proc: p	para: y	cmd: 9
find num:	1
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

9(11)
ready to run:p	cmd: 9	11
para: y=11
run cmd: 9
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

12
cond	false:	8
handleCmd:8 with paraid:7
para name:y	run cmd:9
binary operation:	0	-	6
num:	1
var:	1
1	-	1
num:	1
var:	1
num:13:	0
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 13:	num
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

y	def:T	type:nil	value:13
p	def:U	type:proc	value:9
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 14:	true
cmd: 13:	num
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

14
cond	true:	4
assignment:	p = cmd: 3
p	def:D	type:int	value:1
y	def:T	type:nil	value:13
p	def:U	type:nil	value:0

rec call: 
1

# using the miniOO part 3:
MALLOC x
cmd: 0:	obj

find num:	0
num:1:	0

cmd: 1:	num
cmd: 0:	obj

x.C= cmd:1 as a int
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj
e proc.
proc: p	para: y	cmd: 9
find var:p
proc: p	para: y	cmd: 9
find num:	1
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

9(11)
ready to run:p	cmd: 9	11
para: y=11
run cmd: 9
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

12
cond	false:	8
handleCmd:8 with paraid:7
para name:y	run cmd:9
binary operation:	0	-	6
num:	1
var:	1
1	-	1
num:	1
var:	1
num:13:	0
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 13:	num
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

y	def:T	type:nil	value:13
p	def:U	type:proc	value:9
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 14:	true
cmd: 13:	num
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

14
cond	true:	4
assignment:	p = cmd: 3
p	def:D	type:int	value:1
y	def:T	type:nil	value:13
p	def:U	type:nil	value:0

rec call: 
1

# using the miniOO part 3:
MALLOC x
cmd: 0:	obj

find num:	0
num:1:	0

cmd: 1:	num
cmd: 0:	obj

x.C= cmd:1 as a int
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.C	def:U	type:nil	value:0

x.C	def:D	type:int	value:0

find var:y
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

find num:	1
num:4:	1
num:1:	0

cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

in handle lesser: not defined:	3
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 5	op: <	3	4

find field:x.C
x.R= cmd:2 as a int
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

6	= cmd:2
cmd: 7	left: x.R	equals cmd:2
find field:x.F
cmd: 8:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:ary operation:	3	<	4
num:	1
var:	2
2	<	1
num:	1
var:	2
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

15
cond	false:	11
handleCmd:11 with paraid:10
para name:y	run cmd:12
binary operation:	3	-	9
num:	1
var:	2
2	-	1
num:	1
var:	2
num:16:	1
num:14:	2
num:9:	1
num:4:	1
num:1:	0

cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:T	type:nil	value:16
x.F	def:U	type:proc	value:12
x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

binary operation:	3	<	4
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 17:	false
cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

17
cond	false:	11
handleCmd:11 with paraid:10
para name:y	run cmd:12
binary operation:	3	-	9
num:	1
var:	1
1	-	1
num:	1
var:	1
num:18:	0
num:16:	1
num:14:	2
num:9:	1
num:4:	1
num:1:	0

cmd: 18:	num
cmd: 17:	false
cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:T	type:nil	value:18
x.F	def:U	type:proc	value:12
x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

binary operation:	3	<	4
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 19:	true
cmd: 18:	num
cmd: 17:	false
cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

19
cond	true:	7
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 629, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 637, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
not in cmd list.
nil
1 is not already assigned.
cmd: 1:	var
cmd: 0:	num

cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num
ke
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 629, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 637, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
not in cmd list.
nil
1 is not already assigned.
cmd: 1:	var
cmd: 0:	num

cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

cmd: 2	op: +	1	-1

r = cmd:2;
r	cmd: 2	in proc now.
cmd: 3	left: r	equals cmd:2

proc y:
p = cmd:3;
p	cmd: 3	in proc now.
now in declare proc.
proc: p	para: y	cmd: 3
find num:	2
num:5:	2
num:0:	1

cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

h = cmd:5;
h	def:D	type:int	value:2
p	def:U	type:proc	value:3
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 3
find num:	4
num:6:	4
num:5:	2
num:0:	1

cmd: 6:	num
cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

3(6)
ready to run:p	cmd: 3	6
para: y=6
run cmd: 3
assignment:	r = cmd: 2
binary operation:	1	+	-1
var:	4
4	+	varid not in cmd list.
-1
varid not in cmd list.
var:	4
num:7:	3
num:6:	4
num:5:	2
num:0:	1

cmd: 7:	num
cmd: 6:	num
cproc.
proc: p	para: y	cmd: 9
find var:p
proc: p	para: y	cmd: 9
find num:	1
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

9(11)
ready to run:p	cmd: 9	11
para: y=11
run cmd: 9
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

12
cond	false:	8
handleCmd:8 with paraid:7
para name:y	run cmd:9
binary operation:	0	-	6
num:	1
var:	1
1	-	1
num:	1
var:	1
num:13:	0
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 13:	num
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

y	def:T	type:nil	value:13
p	def:U	type:proc	value:9
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 14:	true
cmd: 13:	num
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

14
cond	true:	4
assignment:	p = cmd: 3
p	def:D	type:int	value:1
y	def:T	type:nil	value:13
p	def:U	type:nil	value:0

rec call: 
1

# using the miniOO part 3:
MALLOC x
cmd: 0:	obj

find num:	0
num:1:	0

cmd: 1:	num
cmd: 0:	obj

x.C= cmd:1 as a int
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.C	def:U	type:nil	value:0

x.C	def:D	type:int	value:0

find var:y
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

find num:	1
num:4:	1
num:1:	0

cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

in handle lesser: not defined:	3
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 5	op: <	3	4

find field:x.C
x.R= cmd:2 as a int
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

6	= cmd:2
cmd: 7	left: x.R	equals cmd:2
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

find field:x.F
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

find var:y
find num:	1
num:9:	1
num:4:	1
num:1:	0

cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

nil
not found all the parameter.
nil
3 is not already assigned.
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 10	op: -	3	9
cmd: 5	op: <	3	4

8(10)
ready to run:nil	cmd: 8	10
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
11

if else
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc y:
x.F= cmd:12 as a proc
8	= cmd:12
now in declare proc.
proc: x.F	para: y	cmd: 12
find field:x.F
proc: x.F	para: y	cmd: 12
find num:	2
num:14:	2
num:9:	1
num:4:	1
num:1:	0

cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

12(14)
ready to run:x.F	cmd: 12	14
para: y=14
run cmd: 12
binary operation:	3	<	4
num:	1
var:	2
2	<	1
num:	1
var:	2
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

15
cond	false:	11
handleCmd:11 with paraid:10
para name:y	run cmd:12
binary operation:	3	-	9
num:	1
var:	2
2	-	1
num:	1
var:	2
num:16:	1
num:14:	2
num:9:	1
num:4:	1
num:1:	0

cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:T	type:nil	value:16
x.F	def:U	type:proc	value:12
x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

binary operation:	3	<	4
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 17:	false
cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

17
cond	false:	11
handleCmd:11 with paraid:10
para name:y	run cmd:12
binary operation:	3	-	9
num:	1
var:	1
1	-	1
num:	1
var:	1
num:18:	0
num:16:	1
num:14:	2
num:9:	1
num:4:	1
num:1:	0

cmd: 18:	num
cmd: 17:	false
cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:T	type:nil	value:18
x.F	def:U	type:proc	value:12
x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

binary operation:	3	<	4
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 19:	true
cmd: 18:	num
cmd: 17:	false
cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

19
cond	true:	7
assignment:	x.R = cmd: 2
cmd not found in bop.
x.R	def:D	type:int	value:-1
y	def:T	type:nil	value:18
x.F	def:U	type:proc	value:12
x.F	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

cmd fid not found.
rec call: 
-1

# the end.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 631, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 639, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
not in cmd list.
nil
1 is not already assigned.
cmd: 1:	var
cmd: 0:	num

cmd: 2:	binop
cmd: 1:	var
cmd: 0:	nummake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 631, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 639, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
not in cmd list.
nil
1 is not already assigned.
cmd: 1:	var
cmd: 0:	num

cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

cmd: 2	op: +	1	-1

r = cmd:2;
r	cmd: 2	in proc now.
cmd: 3	left: r	equals cmd:2

proc y:
p = cmd:3;
p	cmd: 3	in proc now.
now in declare proc.
proc: p	para: y	cmd: 3
find num:	2
num:5:	2
num:0:	1

cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

h = cmd:5;
h	def:D	type:int	value:2
p	def:U	type:proc	value:3
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 3
find num:	4
num:6:	4
num:5:	2
num:0:	1

cmd: 6:	num
cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

3(6)
ready to run:p	cmd: 3	6
para: y=6
run cmd: 3
assignment:	r = cmd: 2
binary operation:	1	+	-1
var:	4
4	+	varid not in cmd list.
-1
varid not in cmd list.
var:	4
num:7:	3
num:6:	4
num:5:	2
num:0:	1

cmd: 7:	num
cmd: 6:	nume proc.
proc: p	para: y	cmd: 9
find var:p
proc: p	para: y	cmd: 9
find num:	1
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

9(11)
ready to run:p	cmd: 9	11
para: y=11
run cmd: 9
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

12
cond	false:	8
handleCmd:8 with paraid:7
para name:y	run cmd:9
binary operation:	0	-	6
num:	1
var:	1
1	-	1
num:	1
var:	1
num:13:	0
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 13:	num
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

y	def:T	type:nil	value:13
p	def:U	type:proc	value:9
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 14:	true
cmd: 13:	num
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

14
cond	true:	4
assignment:	p = cmd: 3
p	def:D	type:int	value:1
y	def:T	type:nil	value:13
p	def:U	type:nil	value:0

rec call: 
1

# using the miniOO part 3:
MALLOC x
cmd: 0:	obj

find num:	0
num:1:	0

cmd: 1:	num
cmd: 0:	obj

x.C= cmd:1 as a int
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj
e proc.
proc: p	para: y	cmd: 9
find var:p
proc: p	para: y	cmd: 9
find num:	1
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

9(11)
ready to run:p	cmd: 9	11
para: y=11
run cmd: 9
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

12
cond	false:	8
handleCmd:8 with paraid:7
para name:y	run cmd:9
binary operation:	0	-	6
num:	1
var:	1
1	-	1
num:	1
var:	1
num:13:	0
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 13:	num
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

y	def:T	type:nil	value:13
p	def:U	type:proc	value:9
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 14:	true
cmd: 13:	num
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

14
cond	true:	4
assignment:	p = cmd: 3
p	def:D	type:int	value:1
y	def:T	type:nil	value:13
p	def:U	type:nil	value:0

rec call: 
1

# using the miniOO part 3:
MALLOC x
cmd: 0:	obj

find num:	0
num:1:	0

cmd: 1:	num
cmd: 0:	obj

x.C= cmd:1 as a int
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.C	def:U	type:nil	value:0

x.C	def:D	type:int	value:0

find var:y
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

find num:	1
num:4:	1
num:1:	0

cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

in handle lesser: not defined:	3
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 5	op: <	3	4

find field:x.C
x.R= cmd:2 as a int
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

6	= cmd:2
cmd: 7	left: x.R	equals cmd:2
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

find fieldd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

12(14)
ready to run:x.F	cmd: 12	14
para: y=14
run cmd: 12
binary operation:	3	<	4
num:	1
var:	2
2	<	1
num:	1
var:	2
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

15
cond	false:	11
handleCmd:11 with paraid:10
para name:y	run cmd:12
binary operation:	3	-	9
num:	1
var:	2
2	-	1
num:	1
var:	2
num:16:	1
num:14:	2
num:9:	1
num:4:	1
num:1:	0

cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:T	type:nil	value:16
x.F	def:U	type:proc	value:12
x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

binary operation:	3	<	4
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 17:	false
cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

17
cond	false:	11
handleCmd:11 with paraid:10
para name:y	run cmd:12
binary operation:	3	-	9
num:	1
var:	1
1	-	1
num:	1
var:	1
num:18:	0
num:16:	1
num:14:	2
num:9:	1
num:4:	1
num:1:	0

cmd: 18:	num
cmd: 17:	false
cmd: 16:	num
d: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

12(14)
ready to run:x.F	cmd: 12	14
para: y=14
run cmd: 12
binary operation:	3	<	4
num:	1
var:	2
2	<	1
num:	1
var:	2
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

15
cond	false:	11
handleCmd:11 with paraid:10
para name:y	run cmd:12
binary operation:	3	-	9
num:	1
var:	2
2	-	1
num:	1
var:	2
num:16:	1
num:14:	2
num:9:	1
num:4:	1
num:1:	0

cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:T	type:nil	value:16
x.F	def:U	type:proc	value:12
x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

binary operation:	3	<	4
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 17:	false
cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

17
cond	false:	11
handleCmd:11 with paraid:10
para name:y	run cmd:12
binary operation:	3	-	9
num:	1
var:	1
1	-	1
num:	1
var:	1
num:18:	0
num:16:	1
num:14:	2
num:9:	1
num:4:	1
num:1:	0

cmd: 18:	num
cmd: 17:	false
cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:T	type:nil	value:18
x.F	def:U	type:proc	value:12
x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

binary operation:	3	<	4
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 19:	true
cmd: 18:	num
cmd: 17:	false
cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

19
cond	true:	7
assignment:	x.R = cmd: 2
x.R	def:D	type:int	value:0
y	def:T	type:nlue:1

nil
not found all the parameter.
not in cmd list.
nil
1 is not already assigned.
cmd: 1:	var
cmd: 0:	num

cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

cmd: 2	op: +	1	-1

r = cmd:2;
r	cmd: 2	in proc now.
cmd: 3	left: r	equals cmd:2

proc y:
p = cmd:3;
p	cmd: 3	in proc now.
now in declare proc.
proc: p	para: y	cmd: 3
find num:	2
num:5:	2
num:0:	1

cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

h = cmd:5;
h	def:D	type:int	value:2
p	def:U	type:proc	value:3
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 3
find num:	4
num:6:	4
num:5:	2
num:0:	1

cmd: 6:	num
cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

3(6)
ready to run:p	cmd: 3	6
para: y=6
run cmd: 3
assignment:	r = cmd: 2
binary operation:	1	+	-1
var:	4
4	+	varid not in cmd list.
-1
varid not in cmd list.
var:	4
num:7:	3
num:6:	4
num:5:	2
num:0:	1

cmd: 7:	num
cmd: 6:	num
cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

7
r	def:D	type:int	value:7
y	def:T	type:nil	value:6
h	def:D	type:int	value:2
p	def:U	type:proc	value:3

rec call: 
3

# using the miniOO part 2:
find var:y
cmd: 0:	var

y	def:U	type:nil	value:0

find num:	1
num:1:	1

cmd: 1:	num
cmd: 0:	var

in handle lesser: not defined:	0
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 2	op: <	0	1

find num:	1
num:3:	1
num:1:	1

cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p = cmd:3;
p	cmd: 3	in proc now.
cmd: 4	left: p	equals cmd:3

find var:p
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
clue:1

nil
not found all the parameter.
not in cmd list.
nil
1 is not already assigned.
cmd: 1:	var
cmd: 0:	num

cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

cmd: 2	op: +	1	-1

r = cmd:2;
r	cmd: 2	in proc now.
cmd: 3	left: r	equals cmd:2

proc y:
p = cmd:3;
p	cmd: 3	in proc now.
now in declare proc.
proc: p	para: y	cmd: 3
find num:	2
num:5:	2
num:0:	1

cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

h = cmd:5;
h	def:D	type:int	value:2
p	def:U	type:proc	value:3
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 3
find num:	4
num:6:	4
num:5:	2
num:0:	1

cmd: 6:	num
cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

3(6)
ready to run:p	cmd: 3	6
para: y=6
run cmd: 3
assignment:	r = cmd: 2
binary operation:	1	+	-1
var:	4
4	+	varid not in cmd list.
-1
varid not in cmd list.
var:	4
num:7:	3
num:6:	4
num:5:	2
num:0:	1

cmd: 7:	num
cmd: 6:	num
cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

7
r	def:D	type:int	value:7
y	def:T	type:nil	value:6
h	def:D	type:int	value:2
p	def:U	type:proc	value:3

rec call: 
3

# using the miniOO part 2:
find var:y
cmd: 0:	var

y	def:U	type:nil	value:0

find num:	1
num:1:	1

cmd: 1:	num
cmd: 0:	var

in handle lesser: not defined:	0
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 2	op: <	0	1

find num:	1
num:3:	1
num:1:	1

cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p = cmd:3;
p	cmd: 3	in proc now.
cmd: 4	left: p	equals cmd:3

find var:p
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

find var:y
find num:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

nil
not found all the parameter.
nil
0 is not already assigned.
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

cmd: 7	op: -	0	6
cmd: 2	op: <	0	1

5(7)
ready to run:nil	cmd: 5	7
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

rec call: 
8

if else
cmd: 9:	cond
cmd: 8:	rec
cmd: g the miniOO part 3:
MALLOC x
cmd: 0:	obj

find num:	0
num:1:	0

cmd: 1:	num
cmd: 0:	obj

x.C= cmd:1 as a int
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.C	def:U	type:nil	value:0

x.C	def:D	type:int	value:0

find var:y
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

find num:	1
num:4:	1
num:1:	0

cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

in handle lesser: not defined:	3
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 5	op: <	3	4

find field:x.C
x.R= cmd:2 as a int
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

6	= cmd:2
cmd: 7	left: x.R	equals cmd:2
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

find field:x.F
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

find var:y
find num:	1
num:9:	1
num:4:	1
num:1:	0

cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

nil
not found all the parameter.
nil
3 is not already assigned.
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: g the miniOO part 3:
MALLOC x
cmd: 0:	obj

find num:	0
num:1:	0

cmd: 1:	num
cmd: 0:	obj

x.C= cmd:1 as a int
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.C	def:U	type:nil	value:0

x.C	def:D	type:int	value:0

find var:y
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

find num:	1
num:4:	1
num:1:	0

cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

in handle lesser: not defined:	3
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 5	op: <	3	4

find field:x.C
x.R= cmd:2 as a int
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

6	= cmd:2
cmd: 7	left: x.R	equals cmd:2
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

find field:x.F
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

find var:y
find num:	1
num:9:	1
num:4:	1
num:1:	0

cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

nil
not found all the parameter.
nil
3 is not already assigned.
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 10	op: -	3	9
cmd: 5	op: <	3	4

8(10)
ready to run:nil	cmd: 8	10
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
11

if else
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc y:
x.F= cmd:12 as a proc
8	= cmd:12
now in declare proc.
proc: x.F	para: y	cmd: 12
find field:x.ation:	3	-	9
num:	1
var:	1
1	-	1
num:	1
var:	1
num:18:	0
num:16:	1
num:14:	2
num:9:	1
num:4:	1
num:1:	0

cmd: 18:	num
cmd: 17:	false
cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:T	type:nil	value:18
x.F	def:U	type:proc	value:12
x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

binary operation:	3	<	4
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 19:	true
cmd: 18:	num
cmd: 17:	false
cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

19
cond	true:	7
assignment:	x.R = cmd: 2
x.R	def:D	type:int	value:0
y	def:T	type:nil	value:18
x.F	def:U	type:proc	value:12
x.F	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

cmd type not found.
rec call: 
-1

# the end.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 630, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 638, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
not in cmd list.
nil
1 is not already assigned.
cmd: 1:	var
cmd: 0:	num

cmd: 2:	binop
cmd: 1:	var
cmd: 0:	nummake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 630, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 638, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
not in cmd list.
nil
1 is not already assigned.
cmd: 1:	var
cmd: 0:	num

cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

cmd: 2	op: +	1	-1

r = cmd:2;
r	cmd: 2	in proc now.
cmd: 3	left: r	equals cmd:2

proc y:
p = cmd:3;
p	cmd: 3	in proc now.
now in declare proc.
proc: p	para: y	cmd: 3
find num:	2
num:5:	2
num:0:	1

cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

h = cmd:5;
h	def:D	type:int	value:2
p	def:U	type:proc	value:3
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 3
find num:	4
num:6:	4
num:5:	2
num:0:	1

cmd: 6:	num
cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

3(6)
ready to run:p	cmd: 3	6
para: y=6
run cmd: 3
assignment:	r = cmd: 2
binary operation:	1	+	-1
var:	4
4	+	varid not in cmd list.
-1
varid not in cmd list.
var:	4
num:7:	3
num:6:	4
num:5:	2
num:0:	1

cmd: 7:	num
cmd: 6:	nume proc.
proc: p	para: y	cmd: 9
find var:p
proc: p	para: y	cmd: 9
find num:	1
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

9(11)
ready to run:p	cmd: 9	11
para: y=11
run cmd: 9
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

12
cond	false:	8
handleCmd:8 with paraid:7
para name:y	run cmd:9
binary operation:	0	-	6
num:	1
var:	1
1	-	1
num:	1
var:	1
num:13:	0
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 13:	num
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

y	def:T	type:nil	value:13
p	def:U	type:proc	value:9
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 14:	true
cmd: 13:	num
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

14
cond	true:	4
assignment:	p = cmd: 3
p	def:D	type:int	value:1
y	def:T	type:nil	value:13
p	def:U	type:nil	value:0

rec call: 
1

# using the miniOO part 3:
MALLOC x
cmd: 0:	obj

find num:	0
num:1:	0

cmd: 1:	num
cmd: 0:	obj

x.C= cmd:1 as a int
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj
e proc.
proc: p	para: y	cmd: 9
find var:p
proc: p	para: y	cmd: 9
find num:	1
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

9(11)
ready to run:p	cmd: 9	11
para: y=11
run cmd: 9
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

12
cond	false:	8
handleCmd:8 with paraid:7
para name:y	run cmd:9
binary operation:	0	-	6
num:	1
var:	1
1	-	1
num:	1
var:	1
num:13:	0
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 13:	num
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

y	def:T	type:nil	value:13
p	def:U	type:proc	value:9
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 14:	true
cmd: 13:	num
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

14
cond	true:	4
assignment:	p = cmd: 3
p	def:D	type:int	value:1
y	def:T	type:nil	value:13
p	def:U	type:nil	value:0

rec call: 
1

# using the miniOO part 3:
MALLOC x
cmd: 0:	obj

find num:	0
num:1:	0

cmd: 1:	num
cmd: 0:	obj

x.C= cmd:1 as a int
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.C	def:U	type:nil	value:0

x.C	def:D	type:int	value:0

find var:y
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

find num:	1
num:4:	1
num:1:	0

cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

in handle lesser: not defined:	3
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 5	op: <	3	4

find field:x.C
x.R= cmd:2 as a int
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

6	= cmd:2
cmd: 7	left: x.R	equals cmd:2
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

find fieldd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

12(14)
ready to run:x.F	cmd: 12	14
para: y=14
run cmd: 12
binary operation:	3	<	4
num:	1
var:	2
2	<	1
num:	1
var:	2
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

15
cond	false:	11
handleCmd:11 with paraid:10
para name:y	run cmd:12
binary operation:	3	-	9
num:	1
var:	2
2	-	1
num:	1
var:	2
num:16:	1
num:14:	2
num:9:	1
num:4:	1
num:1:	0

cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:T	type:nil	value:16
x.F	def:U	type:proc	value:12
x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

binary operation:	3	<	4
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 17:	false
cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

17
cond	false:	11
handleCmd:11 with paraid:10
para name:y	run cmd:12
binary operation:	3	-	9
num:	1
var:	1
1	-	1
num:	1
var:	1
num:18:	0
num:16:	1
num:14:	2
num:9:	1
num:4:	1
num:1:	0

cmd: 18:	num
cmd: 17:	false
cmd: 16:	num
d: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

12(14)
ready to run:x.F	cmd: 12	14
para: y=14
run cmd: 12
binary operation:	3	<	4
num:	1
var:	2
2	<	1
num:	1
var:	2
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

15
cond	false:	11
handleCmd:11 with paraid:10
para name:y	run cmd:12
binary operation:	3	-	9
num:	1
var:	2
2	-	1
num:	1
var:	2
num:16:	1
num:14:	2
num:9:	1
num:4:	1
num:1:	0

cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:T	type:nil	value:16
x.F	def:U	type:proc	value:12
x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

binary operation:	3	<	4
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 17:	false
cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

17
cond	false:	11
handleCmd:11 with paraid:10
para name:y	run cmd:12
binary operation:	3	-	9
num:	1
var:	1
1	-	1
num:	1
var:	1
num:18:	0
num:16:	1
num:14:	2
num:9:	1
num:4:	1
num:1:	0

cmd: 18:	num
cmd: 17:	false
cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:T	type:nil	value:18
x.F	def:U	type:proc	value:12
x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

binary operation:	3	<	4
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 19:	true
cmd: 18:	num
cmd: 17:	false
cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

19
cond	true:	7
assignment:	x.R = cmd: 2
cmd not found in bop.
x.R	def:D	type:int	:0
h	def:U	type:int	value:1

nil
not found all the parameter.
not in cmd list.
nil
1 is not already assigned.
cmd: 1:	var
cmd: 0:	num

cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

cmd: 2	op: +	1	-1

r = cmd:2;
r	cmd: 2	in proc now.
cmd: 3	left: r	equals cmd:2

proc y:
p = cmd:3;
p	cmd: 3	in proc now.
now in declare proc.
proc: p	para: y	cmd: 3
find num:	2
num:5:	2
num:0:	1

cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

h = cmd:5;
h	def:D	type:int	value:2
p	def:U	type:proc	value:3
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 3
find num:	4
num:6:	4
num:5:	2
num:0:	1

cmd: 6:	num
cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

3(6)
ready to run:p	cmd: 3	6
para: y=6
run cmd: 3
assignment:	r = cmd: 2
binary operation:	1	+	-1
var:	4
4	+	varid not in cmd list.
-1
varid not in cmd list.
var:	4
num:7:	3
num:6:	4
num:5:	2
num:0:	1

cmd: 7:	num
cmd: 6:	num
cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

7
r	def:D	type:int	value:7
y	def:T	type:nil	value:6
h	def:D	type:int	value:2
p	def:U	type:proc	value:3

rec call: 
3

# using the miniOO part 2:
find var:y
cmd: 0:	var

y	def:U	type:nil	value:0

find num:	1
num:1:	1

cmd: 1:	num
cmd: 0:	var

in handle lesser: not defined:	0
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 2	op: <	0	1

find num:	1
num:3:	1
num:1:	1

cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p = cmd:3;
p	cmd: 3	in proc now.
cmd: 4	left: p	equals cmd:3

find var:p
cmd: 5:	var
cmd: 4:	ass
cmd: 3:0
h	def:U	type:int	value:1

nil
not found all the parameter.
not in cmd list.
nil
1 is not already assigned.
cmd: 1:	var
cmd: 0:	num

cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

cmd: 2	op: +	1	-1

r = cmd:2;
r	cmd: 2	in proc now.
cmd: 3	left: r	equals cmd:2

proc y:
p = cmd:3;
p	cmd: 3	in proc now.
now in declare proc.
proc: p	para: y	cmd: 3
find num:	2
num:5:	2
num:0:	1

cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

h = cmd:5;
h	def:D	type:int	value:2
p	def:U	type:proc	value:3
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 3
find num:	4
num:6:	4
num:5:	2
num:0:	1

cmd: 6:	num
cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

3(6)
ready to run:p	cmd: 3	6
para: y=6
run cmd: 3
assignment:	r = cmd: 2
binary operation:	1	+	-1
var:	4
4	+	varid not in cmd list.
-1
varid not in cmd list.
var:	4
num:7:	3
num:6:	4
num:5:	2
num:0:	1

cmd: 7:	num
cmd: 6:	num
cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

7
r	def:D	type:int	value:7
y	def:T	type:nil	value:6
h	def:D	type:int	value:2
p	def:U	type:proc	value:3

rec call: 
3

# using the miniOO part 2:
find var:y
cmd: 0:	var

y	def:U	type:nil	value:0

find num:	1
num:1:	1

cmd: 1:	num
cmd: 0:	var

in handle lesser: not defined:	0
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 2	op: <	0	1

find num:	1
num:3:	1
num:1:	1

cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p = cmd:3;
p	cmd: 3	in proc now.
cmd: 4	left: p	equals cmd:3

find var:p
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

find var:y
find num:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

nil
not found all the parameter.
nil
0 is not already assigned.
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

cmd: 7	op: -	0	6
cmd: 2	op: <	0	1

5(7)
ready to run:nil	cmd: 5	7
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

rec call: 
8

if else
cmd: 9:	crec call: 
1

# using the miniOO part 3:
MALLOC x
cmd: 0:	obj

find num:	0
num:1:	0

cmd: 1:	num
cmd: 0:	obj

x.C= cmd:1 as a int
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.C	def:U	type:nil	value:0

x.C	def:D	type:int	value:0

find var:y
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

find num:	1
num:4:	1
num:1:	0

cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

in handle lesser: not defined:	3
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 5	op: <	3	4

find field:x.C
x.R= cmd:2 as a int
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

6	= cmd:2
cmd: 7	left: x.R	equals cmd:2
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

find field:x.F
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

find var:y
find num:	1
num:9:	1
num:4:	1
num:1:	0

cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

nil
not found all the parameter.
nil
3 is not already assigned.
cmd: 3:	var
cmd: 9:	nurec call: 
1

# using the miniOO part 3:
MALLOC x
cmd: 0:	obj

find num:	0
num:1:	0

cmd: 1:	num
cmd: 0:	obj

x.C= cmd:1 as a int
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.C	def:U	type:nil	value:0

x.C	def:D	type:int	value:0

find var:y
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

find num:	1
num:4:	1
num:1:	0

cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

in handle lesser: not defined:	3
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 5	op: <	3	4

find field:x.C
x.R= cmd:2 as a int
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

6	= cmd:2
cmd: 7	left: x.R	equals cmd:2
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

find field:x.F
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

find var:y
find num:	1
num:9:	1
num:4:	1
num:1:	0

cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

nil
not found all the parameter.
nil
3 is not already assigned.
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 10	op: -	3	9
cmd: 5	op: <	3	4

8(10)
ready to run:nil	cmd: 8	10
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
11

if else
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc y:
x.F= cmd:12 as a proc
8	= cmd:12
now in declare proc.
proc: x.F	para: yrun cmd:12
binary operation:	3	-	9
num:	1
var:	1
1	-	1
num:	1
var:	1
num:18:	0
num:16:	1
num:14:	2
num:9:	1
num:4:	1
num:1:	0

cmd: 18:	num
cmd: 17:	false
cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:T	type:nil	value:18
x.F	def:U	type:proc	value:12
x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

binary operation:	3	<	4
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 19:	true
cmd: 18:	num
cmd: 17:	false
cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

19
cond	true:	7
assignment:	x.R = cmd: 2
x.R	def:D	type:int	value:0
y	def:T	type:nil	value:18
x.F	def:U	type:proc	value:12
x.F	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

cmd type not found.
rec call: 
-1

# the end.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 632, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 640, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
not in cmd list.
nil
1 is not already assigned.
cmd: 1:	var
cmd: 0:	num

cmd: 2:	binop
cmd: 1:	var
cmd: 0:	nummake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 632, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 640, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
not in cmd list.
nil
1 is not already assigned.
cmd: 1:	var
cmd: 0:	num

cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

cmd: 2	op: +	1	-1

r = cmd:2;
r	cmd: 2	in proc now.
cmd: 3	left: r	equals cmd:2

proc y:
p = cmd:3;
p	cmd: 3	in proc now.
now in declare proc.
proc: p	para: y	cmd: 3
find num:	2
num:5:	2
num:0:	1

cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

h = cmd:5;
h	def:D	type:int	value:2
p	def:U	type:proc	value:3
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 3
find num:	4
num:6:	4
num:5:	2
num:0:	1

cmd: 6:	num
cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

3(6)
ready to run:p	cmd: 3	6
para: y=6
run cmd: 3
assignment:	r = cmd: 2
binary operation:	1	+	-1
var:	4
4	+	varid not in cmd list.
-1
varid not in cmd list.
var:	4
num:7:	3
num:6:	4
num:5:	2
num:0:	1

cmd: 7:	num
cmd: 6:	nume proc.
proc: p	para: y	cmd: 9
find var:p
proc: p	para: y	cmd: 9
find num:	1
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

9(11)
ready to run:p	cmd: 9	11
para: y=11
run cmd: 9
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

12
cond	false:	8
handleCmd:8 with paraid:7
para name:y	run cmd:9
binary operation:	0	-	6
num:	1
var:	1
1	-	1
num:	1
var:	1
num:13:	0
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 13:	num
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

y	def:T	type:nil	value:13
p	def:U	type:proc	value:9
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 14:	true
cmd: 13:	num
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

14
cond	true:	4
assignment:	p = cmd: 3
p	def:D	type:int	value:1
y	def:T	type:nil	value:13
p	def:U	type:nil	value:0

rec call: 
1

# using the miniOO part 3:
MALLOC x
cmd: 0:	obj

find num:	0
num:1:	0

cmd: 1:	num
cmd: 0:	obj

x.C= cmd:1 as a int
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj
e proc.
proc: p	para: y	cmd: 9
find var:p
proc: p	para: y	cmd: 9
find num:	1
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

9(11)
ready to run:p	cmd: 9	11
para: y=11
run cmd: 9
binary operation:	0	<	1
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

12
cond	false:	8
handleCmd:8 with paraid:7
para name:y	run cmd:9
binary operation:	0	-	6
num:	1
var:	1
1	-	1
num:	1
var:	1
num:13:	0
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 13:	num
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

y	def:T	type:nil	value:13
p	def:U	type:proc	value:9
p	def:U	type:nil	value:0

binary operation:	0	<	1
num:	1
var:	0
0	<	1
num:	1
var:	0
cmd: 14:	true
cmd: 13:	num
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	var
cmd: 4:	ass
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

14
cond	true:	4
assignment:	p = cmd: 3
p	def:D	type:int	value:1
y	def:T	type:nil	value:13
p	def:U	type:nil	value:0

rec call: 
1

# using the miniOO part 3:
MALLOC x
cmd: 0:	obj

find num:	0
num:1:	0

cmd: 1:	num
cmd: 0:	obj

x.C= cmd:1 as a int
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.C	def:U	type:nil	value:0

x.C	def:D	type:int	value:0

find var:y
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

find num:	1
num:4:	1
num:1:	0

cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

in handle lesser: not defined:	3
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 5	op: <	3	4

find field:x.C
x.R= cmd:2 as a int
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

6	= cmd:2
cmd: 7	left: x.R	equals cmd:2
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 3:	var
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

find fieldd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

12(14)
ready to run:x.F	cmd: 12	14
para: y=14
run cmd: 12
binary operation:	3	<	4
num:	1
var:	2
2	<	1
num:	1
var:	2
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

15
cond	false:	11
handleCmd:11 with paraid:10
para name:y	run cmd:12
binary operation:	3	-	9
num:	1
var:	2
2	-	1
num:	1
var:	2
num:16:	1
num:14:	2
num:9:	1
num:4:	1
num:1:	0

cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:T	type:nil	value:16
x.F	def:U	type:proc	value:12
x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
x.C	def:D	type:int	value:0

binary operation:	3	<	4
num:	1
var:	1
1	<	1
num:	1
var:	1
cmd: 17:	false
cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

17
cond	false:	11
handleCmd:11 with paraid:10
para name:y	run cmd:12
binary operation:	3	-	9
num:	1
var:	1
1	-	1
num:	1
var:	1
num:18:	0
num:16:	1
num:14:	2
num:9:	1
num:4:	1
num:1:	0

cmd: 18:	num
cmd: 17:	false
cmd: 16:	num
d: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

12(14)
ready to run:x.F	cmd: 12	14
para: y=14
run cmd: 12
binary operation:	3	<	4
num:	1
var:	2
2	<	1
num:	1
var:	2
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

15
cond	false:	11
handleCmd:11 with paraid:10
para name:y	run cmd:12
binary operation:	3	-	9
num:	1
var:	2
2	-	1
num:	1
var:	2
num:16:	1
num:14:	2
num:9:	1
num:4:	1
num:1:	0

cmd: 16:	num
cmd: 15:	false
cmd: 14:	num
cmd: 13:	proc
cmd: 12:	cond
cmd: 11:	rec
cmd: 10:	binop
cmd: 3:	var
cmd: 9:	num
cmd: 8:	field
cmd: 7:	ass
cmd: 6:	field
cmd: 5:	binop
cmd: 4:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:T	type:nil	value:make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 634, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 642, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
not in cmd list.
nil
1 is not already assigned.
cmd: 1:	var
cmd: 0:	num

cmd: 2:	binop
cmd: 1:	var
cmd: 0:	nummake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 634, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 642, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
not in cmd list.
nil
1 is not already assigned.
cmd: 1:	var
cmd: 0:	num

cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

cmd: 2	op: +	1	-1

r = cmd:2;
r	cmd: 2	in proc now.
cmd: 3	left: r	equals cmd:2

proc y:
p = cmd:3;
p	cmd: 3	in proc now.
now in declare proc.
proc: p	para: y	cmd: 3
find num:	2
num:5:	2
num:0:	1

cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

h = cmd:5;
h	def:D	type:int	value:2
p	def:U	type:proc	value:3
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 3
find num:	4
num:6:	4
num:5:	2
num:0:	1

cmd: 6:	num
cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

3(6)
ready to run:p	cmd: 3	6
para: y=6
run cmd: 3
assignment:	r = cmd: 2
binary operation:	1	+	-1
var:	4
4	+	varid not in cmd list.
-1
varid not in cmd list.
var:	4
num:7:	3
num:6:	4
num:5:	2
num:0:	1

cmd: 7:	num
cmd: 6:	num7
cmd not found in bop.
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 634, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 642, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
not in cmd list.
nil
1 is not already assigned.
cmd: 1:	var
cmd: 0:	num

cmd: 2:	binop
cmd: 1:	var
cmd: 0:	nummake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 634, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 642, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
not in cmd list.
nil
1 is not already assigned.
cmd: 1:	var
cmd: 0:	num

cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

cmd: 2	op: +	1	-1

r = cmd:2;
r	cmd: 2	in proc now.
cmd: 3	left: r	equals cmd:2

proc y:
p = cmd:3;
p	cmd: 3	in proc now.
now in declare proc.
proc: p	para: y	cmd: 3
find num:	2
num:5:	2
num:0:	1

cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

h = cmd:5;
h	def:D	type:int	value:2
p	def:U	type:proc	value:3
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 3
find num:	4
num:6:	4
num:5:	2
num:0:	1

cmd: 6:	num
cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

3(6)
ready to run:p	cmd: 3	6
para: y=6
run cmd: 3
assignment:	r = cmd: 2
binary operation:	1	+	-1
var:	4
4	+	varid not in cmd list.
-1
varid not in cmd list.
var:	4
num:7:	3
num:6:	4
num:5:	2
num:0:	1

cmd: 7:	num
cmd: 6:	num7
cmd not found in bop.
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 180, characters 46-55:
Error: Unbound value handleNum
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 645, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 653, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
not in cmd list.
nil
1 is not already assigned.
cmd: 1:	var
cmd: 0:	num

cmd: 2:	binop
cmd: 1:	var
cmd: 0:	nummake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 645, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 653, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
h	def:U	type:int	value:1

find var:y
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
not in cmd list.
nil
1 is not already assigned.
cmd: 1:	var
cmd: 0:	num

cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

cmd: 2	op: +	1	-1

r = cmd:2;
r	cmd: 2	in proc now.
cmd: 3	left: r	equals cmd:2

proc y:
p = cmd:3;
p	cmd: 3	in proc now.
now in declare proc.
proc: p	para: y	cmd: 3
find num:	2
num:5:	2
num:0:	1

cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

h = cmd:5;
num:6:	2
num:5:	2
num:0:	1

cmd: 6:	num
cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

h	def:D	type:int	value:6
p	def:U	type:proc	value:3
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 3
find num:	4
num:7:	4
num:6:	2
num:5:	2
num:0:	1

cmd: 7:	num
cmd: 6:	num
cmd: 5:	num
cmd: 4:	proc
cmd: 3:	ass
cmd: 2:	binop
cmd: 1:	var
cmd: 0:	num

3(7)
ready to run:p	cmd: 3	7
para: y=7
run cmd: 3
assignment:	r = cmd: 2
binary operatimd: 8:	proc
cmd: 7:	cond
cmd: 6:	rec
cmd: 5:	binop
cmd: 0:	var
cmd: 4:	num
cmd: 3:	num
cmd: 2:	true
cmd: 1:	num

7(9)
ready to run:p	cmd: 7	9
para: y=9
run cmd: 7
cmd not found in bop.
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 645, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 653, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
num:1:	1
num:0:	1

cmd: 1:	num
cmd: 0:	num

h	def:U	type:int	value:1

find var:y
cmd: 2:	var
cmd: 1:	num
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
not in cmd list.
nil
2 is not already assigned.
cmd:make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 645, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 653, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
num:1:	1
num:0:	1

cmd: 1:	num
cmd: 0:	num

h	def:U	type:int	value:1

find var:y
cmd: 2:	var
cmd: 1:	num
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
not in cmd list.
nil
2 is not already assigned.
cmd: 2:	var
cmd: 1:	num
cmd: 0:	num

cmd: 3:	binop
cmd: 2:	var
cmd: 1:	num
cmd: 0:	num

cmd: 3	op: +	2	-1

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 4	left: r	equals cmd:3

proc y:
p = cmd:4;
p	cmd: 4	in proc now.
now in declare proc.
proc: p	para: y	cmd: 4
find num:	2
num:6:	2
num:1:	1
num:0:	1

cmd: 6:	num
cmd: 5:	proc
cmd: 4:	ass
cmd: 3:	binop
cmd: 2:	var
cmd: 1:	num
cmd: 0:	num

h = cmd:6;
num:7:	2
num:6:	2
num:1:	1
num:0:	1

cmd: 7:	num
cmd: 6:	num
cmd: 5:	proc
cmd: 4:	ass
cmd: 3:	binop
cmd: 2:	var
cmd: 1:	num
cmd: 0:	num

h	def:D	type:int	value:7
p	def:U	type:proc	value:4
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 4
find num:	4
num:8:	4
num:7:	2
num:6:	2
num:1:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	num
cmd: 5:	proc
cmd: 1:	num

rec call: 
7

if else
cmd: 8:	cond
cmd: 7:	rec
cmd: 6:	binop
cmd: 0:	var
cmd: 5:	num
cmd: 4:	num
cmd: 3:	num
cmd: 2:	true
cmd: 1:	num

proc y:
p = cmd:8;
p	cmd: 8	in proc now.
now in declare proc.
proc: p	para: y	cmd: 8
find var:p
proc: p	para: y	cmd: 8
find num:	1
num:10:	1
num:5:	1
num:4:	1
num:3:	1
num:1:	1

cmd: 10:	num
cmd: 9:	proc
cmd: 8:	cond
cmd: 7:	rec
cmd: 6:	binop
cmd: 0:	var
cmd: 5:	num
cmd: 4:	num
cmd: 3:	num
cmd: 2:	true
cmd: 1:	num

8(10)
ready to run:p	cmd: 8	10
para: y=10
run cmd: 8
cmd not found in bop.
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 645, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 653, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
num:1:	1
num:0:	1

cmd: 1:	num
cmd: 0:	num

h	def:U	type:int	value:1

find var:y
cmd: 2:	var
cmd: 1:	num
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
not in cmd list.
nil
2 is not already assigned.
cmd:make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 645, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 653, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
num:1:	1
num:0:	1

cmd: 1:	num
cmd: 0:	num

h	def:U	type:int	value:1

find var:y
cmd: 2:	var
cmd: 1:	num
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
not in cmd list.
nil
2 is not already assigned.
cmd: 2:	var
cmd: 1:	num
cmd: 0:	num

cmd: 3:	binop
cmd: 2:	var
cmd: 1:	num
cmd: 0:	num

cmd: 3	op: +	2	-1

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 4	left: r	equals cmd:3

proc y:
p = cmd:4;
p	cmd: 4	in proc now.
now in declare proc.
proc: p	para: y	cmd: 4
find num:	2
num:6:	2
num:1:	1
num:0:	1

cmd: 6:	num
cmd: 5:	proc
cmd: 4:	ass
cmd: 3:	binop
cmd: 2:	var
cmd: 1:	num
cmd: 0:	num

h = cmd:6;
num:7:	2
num:6:	2
num:1:	1
num:0:	1

cmd: 7:	num
cmd: 6:	num
cmd: 5:	proc
cmd: 4:	ass
cmd: 3:	binop
cmd: 2:	var
cmd: 1:	num
cmd: 0:	num

h	def:D	type:int	value:7
p	def:U	type:proc	value:4
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 4
find num:	4
num:8:	4
num:7:	2
num:6:	2
num:1:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	num
cmd: 5:	proc
cmd: 1:	num

rec call: 
7

if else
cmd: 8:	cond
cmd: 7:	rec
cmd: 6:	binop
cmd: 0:	var
cmd: 5:	num
cmd: 4:	num
cmd: 3:	num
cmd: 2:	true
cmd: 1:	num

proc y:
p = cmd:8;
p	cmd: 8	in proc now.
now in declare proc.
proc: p	para: y	cmd: 8
find var:p
proc: p	para: y	cmd: 8
find num:	1
num:10:	1
num:5:	1
num:4:	1
num:3:	1
num:1:	1

cmd: 10:	num
cmd: 9:	proc
cmd: 8:	cond
cmd: 7:	rec
cmd: 6:	binop
cmd: 0:	var
cmd: 5:	num
cmd: 4:	num
cmd: 3:	num
cmd: 2:	true
cmd: 1:	num

8(10)
ready to run:p	cmd: 8	10
para: y=10
run cmd: 8
cmd not found in bop.
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 647, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 655, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
1
num:1:	1
num:0:	1

cmd: 1:	num
cmd: 0:	num

h	def:U	type:int	value:1

find var:y
cmd: 2:	var
cmd: 1:	num
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
not in cmd list.
nil
2 is not already assigned.
cmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 647, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 655, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

h = cmd:0;
1
num:1:	1
num:0:	1

cmd: 1:	num
cmd: 0:	num

h	def:U	type:int	value:1

find var:y
cmd: 2:	var
cmd: 1:	num
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:U	type:int	value:1

find var:h
y	def:U	type:nil	value:0
h	def:U	type:int	value:1

nil
not found all the parameter.
not in cmd list.
nil
2 is not already assigned.
cmd: 2:	var
cmd: 1:	num
cmd: 0:	num

cmd: 3:	binop
cmd: 2:	var
cmd: 1:	num
cmd: 0:	num

cmd: 3	op: +	2	-1

r = cmd:3;
r	cmd: 3	in proc now.
cmd: 4	left: r	equals cmd:3

proc y:
p = cmd:4;
p	cmd: 4	in proc now.
now in declare proc.
proc: p	para: y	cmd: 4
find num:	2
num:6:	2
num:1:	1
num:0:	1

cmd: 6:	num
cmd: 5:	proc
cmd: 4:	ass
cmd: 3:	binop
cmd: 2:	var
cmd: 1:	num
cmd: 0:	num

h = cmd:6;
2
num:7:	2
num:6:	2
num:1:	1
num:0:	1

cmd: 7:	num
cmd: 6:	num
cmd: 5:	proc
cmd: 4:	ass
cmd: 3:	binop
cmd: 2:	var
cmd: 1:	num
cmd: 0:	num

h	def:D	type:int	value:7
p	def:U	type:proc	value:4
y	def:U	type:nil	value:0

find var:p
proc: p	para: y	cmd: 4
find num:	4
num:8:	4
num:7:	2
num:6:	2
num:1:	1
num:0:	1

cmd: 8:	num
cmd: 7:	num
cmd: 6:	num
cmd: 5:	prod: 2:	true
cmd: 1:	num

rec call: 
7

if else
cmd: 8:	cond
cmd: 7:	rec
cmd: 6:	binop
cmd: 0:	var
cmd: 5:	num
cmd: 4:	num
cmd: 3:	num
cmd: 2:	true
cmd: 1:	num

proc y:
p = cmd:8;
p	cmd: 8	in proc now.
now in declare proc.
proc: p	para: y	cmd: 8
find var:p
proc: p	para: y	cmd: 8
find num:	1
num:10:	1
num:5:	1
num:4:	1
num:3:	1
num:1:	1

cmd: 10:	num
cmd: 9:	proc
cmd: 8:	cond
cmd: 7:	rec
cmd: 6:	binop
cmd: 0:	var
cmd: 5:	num
cmd: 4:	num
cmd: 3:	num
cmd: 2:	true
cmd: 1:	num

8(10)
ready to run:p	cmd: 8	10
para: y=10
run cmd: 8
cmd not found in bop.
Fatal error: exception Not_found
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 647, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 655, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 818, characters 23-34:
Warning 10: this expression should have type unit.
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

cmd: 1:	var
cmd: 0:	num

h	def:U	type:nil	value:0

h = cmd:0;
1
num:2:	1
num:0:	1

cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

h	def:D	type:int	value:2

find var:y
cmd: 3:	var
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	vake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 647, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 655, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 818, characters 23-34:
Warning 10: this expression should have type unit.
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

cmd: 1:	var
cmd: 0:	num

h	def:U	type:nil	value:0

h = cmd:0;
1
num:2:	1
num:0:	1

cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

h	def:D	type:int	value:2

find var:y
cmd: 3:	var
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:D	type:int	value:2

find var:h
y	def:U	type:nil	value:0
h	def:D	type:int	value:2

nil
not found all the parameter.
int
1 is  assigned.
1
num:5:	1
num:2:	1
num:0:	1

cmd: 5:	num
cmd: 3:	var
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

nil
3 is not already assigned.
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

cmd: 4:	binop
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

cmd: 4	op: +	3	5

cmd: 6:	var
cmd: 4:	binop
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

r	def:U	type:nil	value:0
y	def:U	type:nil	value:0
h	def:D	type:int	value:2

r = cmd:4;
r	cmd: 4	in proc now.
cmd: 7	left: r	equals cmd:4

proc y:
cmd: 8:	var
cmd: 7:	ass
cmd: 6:	var
cmd: 4:	binop
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: 1 call: 
5

# using the miniOO part 2:
find var:y
cmd: 0:	var

y	def:U	type:nil	value:0

find num:	1
num:1:	1

cmd: 1:	num
cmd: 0:	var

1
in handle lesser: all defined:	cmd: 2:	true
cmd: 1:	num
cmd: 0:	var

find num:	1
num:3:	1
num:1:	1

cmd: 3:	num
cmd: 2:	true
cmd: 1:	num
cmd: 0:	var

cmd: 4:	var
cmd: 3:	num
cmd: 2:	true
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

p = cmd:3;
1
num:5:	1
num:3:	1
num:1:	1

cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	true
cmd: 1:	num
cmd: 0:	var

p	def:D	type:int	value:5
y	def:U	type:nil	value:0

find var:p
find var:y
find num:	1
num:6:	1
num:5:	1
num:3:	1
num:1:	1

cmd: 6:	num
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	true
cmd: 1:	num
cmd: 0:	var

p	def:D	type:int	value:5
y	def:U	type:nil	value:0

nil
not found all the parameter.
nil
0 is not already assigned.
cmd: 0:	var
cmd: 6:	num
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	true
cmd: 1:	num

cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	true
cmd: 1:	num

cmd: 7	op: -	0	6

4(7)
ready to run:nil	cmd: 4	7
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	true
cmd: 1:	num

rec call: 
8

if else
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	true
cmd: 1:	num

proc y:
p = cmd:9;
p	cmd: 9	in proc now.
now in declare proc.
proc: p	para: y	cmd: 9
find var:p
proc: p	para: y	cmd: 9
find num:	1
num:11:	1
num:6:	1
num:5:	1
num:3:	1
num:1:	 call: 
5

# using the miniOO part 2:
find var:y
cmd: 0:	var

y	def:U	type:nil	value:0

find num:	1
num:1:	1

cmd: 1:	num
cmd: 0:	var

1
in handle lesser: all defined:	cmd: 2:	true
cmd: 1:	num
cmd: 0:	var

find num:	1
num:3:	1
num:1:	1

cmd: 3:	num
cmd: 2:	true
cmd: 1:	num
cmd: 0:	var

cmdmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 647, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 655, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 818, characters 23-34:
Warning 10: this expression should have type unit.
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

cmd: 1:	var
cmd: 0:	num

h	def:U	type:nil	value:0

h = cmd:0;
1
num:2:	1
num:0:	1

cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

h	def:D	type:int	value:2

find var:y
cmd: 3:	var
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 647, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 655, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 818, characters 23-34:
Warning 10: this expression should have type unit.
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

cmd: 1:	var
cmd: 0:	num

h	def:U	type:nil	value:0

h = cmd:0;
1
num:2:	1
num:0:	1

cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

h	def:D	type:int	value:2

find var:y
cmd: 3:	var
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:D	type:int	value:2

find var:h
y	def:U	type:nil	value:0
h	def:D	type:int	value:2

nil
not found all the parameter.
int
1 is  assigned.
1
num:5:	1
num:2:	1
num:0:	1

cmd: 5:	num
cmd: 3:	var
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

nil
3 is not already assigned.
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

cmd: 4:	binop
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

cmd: 4	op: +	3	5

cmd: 6:	var
cmd: 4:	binop
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

r	def:U	type:nil	value:0
y	def:U	type:nil	value:0
h	def:D	type:int	value:2

r = cmd:4;
r	cmd: 4	in proc now.
cmd: 7	left: r	equals cmd:4

proc y:
cmd: 8:	var
cmd: 7:	ass
cmd: 6:	var
cmd: 4:	binop
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: y
cmd: 0:	var

y	def:U	type:nil	value:0

find num:	1
num:1:	1

cmd: 1:	num
cmd: 0:	var

1
in handle lesser: all defined:	cmd: 2:	true
cmd: 1:	num
cmd: 0:	var

find num:	1
num:3:	1
num:1:	1

cmd: 3:	num
cmd: 2:	true
cmd: 1:	num
cmd: 0:	var

cmd: 4:	var
cmd: 3:	num
cmd: 2:	true
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

p = cmd:3;
1
num:5:	1
num:3:	1
num:1:	1

cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	true
cmd: 1:	num
cmd: 0:	var

p	def:D	type:int	value:5
y	def:U	type:nil	value:0

find var:p
find var:y
find num:	1
num:6:	1
num:5:	1
num:3:	1
num:1:	1

cmd: 6:	num
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	true
cmd: 1:	num
cmd: 0:	var

p	def:D	type:int	value:5
y	def:U	type:nil	value:0

nil
not found all the parameter.
nil
0 is not already assigned.
cmd: 0:	var
cmd: 6:	num
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	true
cmd: 1:	num

cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	true
cmd: 1:	num

cmd: 7	op: -	0	6

4(7)
ready to run:nil	cmd: 4	7
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	true
cmd: 1:	num

rec call: 
8

if else
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	true
cmd: 1:	num

proc y:
p = cmd:9;
p	cmd: 9	in proc now.
now in declare proc.
proc: p	para: y	cmd: 9
find var:p
proc: p	para: y	cmd: 9
find num:	1
num:11:	1
num:6:	1
num:5:	1
num:3:	1
num:1:	1

cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmdy
cmd: 0:	var

y	def:U	type:nil	value:0

find num:	1
num:1:	1

cmd: 1:	num
cmd: 0:	var

1
in handle lesser: all defined:	cmd: 2:	true
cmd: 1:	num
cmd: 0:	var

find num:	1
num:3:	1
num:1:	1

cmd: 3:	num
cmd: 2:	true
cmd: 1:	num
cmd: 0:	var

cmdmake
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 647, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 655, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 818, characters 23-34:
Warning 10: this expression should have type unit.
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

cmd: 1:	var
cmd: 0:	num

h	def:U	type:nil	value:0

h = cmd:0;
1
num:2:	1
num:0:	1

cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

h	def:D	type:int	value:2

find var:y
cmd: 3:	var
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 647, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 655, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 818, characters 23-34:
Warning 10: this expression should have type unit.
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

cmd: 1:	var
cmd: 0:	num

h	def:U	type:nil	value:0

h = cmd:0;
1
num:2:	1
num:0:	1

cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

h	def:D	type:int	value:2

find var:y
cmd: 3:	var
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:D	type:int	value:2

find var:h
y	def:U	type:nil	value:0
h	def:D	type:int	value:2

nil
not found all the parameter.
int
1 is  assigned.
1
num:5:	1
num:2:	1
num:0:	1

cmd: 5:	num
cmd: 3:	var
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

nil
3 is not already assigned.
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

cmd: 4:	binop
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

cmd: 4	op: +	3	5

cmd: 6:	var
cmd: 4:	binop
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

r	def:U	type:nil	value:0
y	def:U	type:nil	value:0
h	def:D	type:int	value:2

r = cmd:4;
r	cmd: 4	in proc now.
cmd: 7	left: r	equals cmd:4

proc y:
cmd: 8:	var
cmd: 7:	ass
cmd: 6:	var
cmd: 4:	binop
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: y
cmd: 0:	var

y	def:U	type:nil	value:0

find num:	1
num:1:	1

cmd: 1:	num
cmd: 0:	var

1
in handle lesser: not defined:	0
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 2	op: <	0	1

find num:	1
num:3:	1
num:1:	1

cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

p = cmd:3;
p	cmd: 3	in proc now.
cmd: 5	left: p	equals cmd:3

find var:p
find var:y
find num:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

nil
not found all the parameter.
nil
0 is not already assigned.
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

cmd: 7	op: -	0	6
cmd: 2	op: <	0	1

4(7)
ready to run:nil	cmd: 4	7
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

rec call: 
8

if else
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

proc y:
p = cmd:9;
p	cmd: 9	in proc now.
now in declare proc.
proc: p	para: y	cmd: 9
find var:p
proc: p	para: y	cmd: 9
find num:	1
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	nuy
cmd: 0:	var

y	def:U	type:nil	value:0

find num:	1
num:1:	1

cmd: 1:	num
cmd: 0:	var

1
in handle lesser: not defined:	0
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 2	op: <	0	1

find num:	1
num:3:	1
num:1:	1

cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

p = cmd:3;
p	cmd: 3	in proc now.
cmd: 5	left: p	equals cmd:3

find var:p
find var:y
find num:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

nil
not found all the parameter.
nil
0 is not already assigned.
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

cmd: 7	op: -	0	6
cmd: 2	op: <	0	1

4(7)
ready to run:nil	cmd: 4	7
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

rec call: 
8

if else
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

proc y:
p = cmd:9;
p	cmd: 9	in proc now.
now in declare proc.
proc: p	para: y	cmd: 9
find var:p
proc: p	para: y	cmd: 9
find num:	1
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

9(11)
ready to run:p	cmd: 9	11
para: y=11
run cmd: 9
binary operation:	0	<	1
num of 1 : 1
var:	1
1	<	1
num of 1 : 1
var:	1
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

12
cond	false:	8
handleCmd:8 with paraid:7
para name:y	run cmd:9
binary operation:	0	-	6
num of 6 : 1
var:	1
1	-	1
num of 6 : 1
var:	1
num:13:	0
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 13:	num
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

y	def:T	type:nil	value:13
p	def:D	type:proc	value:9

binary operat:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

find var:y
find num:	1
num:10:	1
num:5:	1
num:3:	0
num:1:	0

cmd: 10:	num
cmd: 9:	field
cmd: 8:	ass
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

nil
not found all the parameter.
nil
4 is not already assigned.
cmd: 4:	var
cmd: 10:	num
cmd: 9:	field
cmd: 8:	ass
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 11:	binop
cmd: 4:	var
cmd: 10:	num
cmd: 9:	field
cmd: 8:	ass
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 11	op: -	4	10
cmd: 6	op: <	4	5

9(11)
ready to run:nil	cmd: 9	11
cmd: 12:	rec
cmd: 11:	binop
cmd: 4:	var
cmd: 10:	num
cmd: 9:	field
cmd: 8:	ass
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
12

if else
cmd: 13:	cond
cmd: 12:	rec
cmd: 11:	binop
cmd: 4:	var
cmd: 10:	num
cmd: 9:	field
cmd: 8:	ass
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc y:
x.F= cmd:13 as a proc
9	= cmd:13
now in declare proc.
proc: x.F	para: y	cmd: 13
find field:x.F
proc: x.F	para: y	cmd: 13
find num:	2
num:15:	2
num:10:	1
num:5:	1
num:3:	0
num:1:	0

cmd: 15:	num
cmd: 14:	proc
cmd: 13:	cond
cmd: 12:	rec
cmd: 11:	binop
cmd: :	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

find var:y
find num:	1
num:10:	1
num:5:	1
num:3:	0
num:1:	0

cmd: 10:	num
cmd: 9:	field
cmd: 8:	ass
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

nil
not found all the parameter.
nil
4 is not already assigned.
cmd: 4:	var
cmd: 10:	num
cmd: 9:	field
cmd: 8:	ass
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 11:	binop
cmd: 4:	var
cmd: 10:	num
cmd: 9:	field
cmd: 8:	ass
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 11	op: -	4	10
cmd: 6	op: <	4	5

9(11)
ready to run:nil	cmd: 9	11
cmd: 12:	rec
cmd: 11:	binop
cmd: 4:	var
cmd: 10:	num
cmd: 9:	field
cmd: 8:	ass
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
12

if else
cmd: 13:	cond
cmd: 12:	rec
cmd: 11:	binop
cmd: 4:	var
cmd: 10:	num
cmd: 9:	field
cmd: 8:	ass
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc y:
x.F= cmd:13 as a proc
9	= cmd:13
now in declare proc.
proc: x.F	para: y	cmd: 13
find field:x.F
proc: x.F	para: y	cmd: 13
find num:	2
num:15:	2
num:10:	1
num:5:	1
num:3:	0
num:1:	0

cmd: 15:	num
cmd: 14:	proc
cmd: 13:	cond
cmd: 12:	rec
cmd: 11:	binop
cmd: 4:	var
cmd: 10:	num
cmd: 9:	field
cmd: 8:	ass
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

13(15)
ready to run:x.F	cmd: 13	15
para: y=15
run cmd: 13
binary operation:	4	<	5
num of 5 : 1
var:	2
2	<	1
num of 5 : 1
var:	2
cmd: 16:	false
cmd: 15:	num
cmd: 14:	proc
cmd: 13:	cond
cmd: 12:	rec
cmd: 11:	binop
cmd: 4:	var
cmd: 10:	num
cmd: 9:	field
cmd: 8:	ass
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

16
cond	false:	12
handleCmd:12 with paraid:11
para name:y	run cmd:13
binary operation:	4	-	10
num of 10 : 1
var:	2
2	-	1
num of 10 : 1
var:	2
num:17:	1
num:15:	2
num:10:	1
num:5:	1
num:3:	0
num:1:	0

cmd: 17:	num
cmd: 16:	false
cmd: 15:	num
cmd: 14:	proc
cmd: md: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

20
cond	true:	8
assignment:	x.R = cmd: 2
0
x.R	def:D	type:int	value:0
y	def:T	type:nil	value:19
x.F	def:U	type:proc	value:13
x.F	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

cmd type not found.
rec call: 
-1

# the end.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 219, characters 8-17:
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 219, characters 9-18:
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 661, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 669, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 832, characters 23-34:
Warning 10: this expression should have type unit.
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README		make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 219, characters 9-18:
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 661, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 669, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 832, characters 23-34:
Warning 10: this expression should have type unit.
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

cmd: 1:	var
cmd: 0:	num

h	def:U	type:nil	value:0

h = cmd:0;
1
num:2:	1
num:0:	1

cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

h	def:D	type:int	value:2

find var:y
cmd: 3:	var
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:D	type:int	value:2

find var:h
y	def:U	type:nil	value:0
h	def:D	type:int	value:2

nil
not found all the parameter.
int
1 is  assigned.
1
num:5:	1
num:2:	1
num:0:cmd: 1:	var
cmd: 0:	num

7(12)
ready to run:p	cmd: 7	12
para: y=12
run cmd: 7
assignment:	r = cmd: 4
binary operation:	3	+	5
var:	4
4	+	num of 5 : 1
1
num of 5 : 1
var:	4
num:13:	5
num:12:	4
num:11:	2
num:10:	2
num:5:	1
num:2:	1
num:0:	1

cmd: 13:	num
cmd: 12:	num
cmd: 11:	num
cmd: 10:	num
cmd: 9:	proc
cmd: 8:	var
cmd: 7:	ass
cmd: 6:	var
cmd: 4:	binop
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

13
r	def:D	type:int	value:13
y	def:T	type:nil	value:12
h	def:D	type:int	value:11
p	def:D	type:proc	value:7

5
rec call: 
5

# using the miniOO part 2:
find var:y
cmd: 0:	var

y	def:U	type:nil	value:0

find num:	1
num:1:	1

cmd: 1:	num
cmd: 0:	var

1
in handle lesser: not defined:	0
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 2	op: <	0	1

find num:	1
num:3:	1
num:1:	1

cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

p = cmd:3;
p	cmd: 3	in proc now.
cmd: 5	left: p	equals cmd:3

find var:p
find var:y
find num:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

nil
not found all the parameter.
nil
0 is not already assigned.
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

cmd: 7	op: -	0	6
cmd: 2	op: <	0	1

4(7)
readycmd: 1:	var
cmd: 0:	num

7(12)
ready to run:p	cmd: 7	12
para: y=12
run cmd: 7
assignment:	r = cmd: 4
binary operation:	3	+	5
var:	4
4	+	num of 5 : 1
1
num of 5 : 1
var:	4
num:13:	5
num:12:	4
num:11:	2
num:10:	2
num:5:	1
num:2:	1
num:0:	1

cmd: 13:	num
cmd: 12:	num
cmd: 11:	num
cmd: 10:	num
cmd: 9:	proc
cmd: 8:	var
cmd: 7:	ass
cmd: 6:	var
cmd: 4:	binop
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

13
r	def:D	type:int	value:13
y	def:T	type:nil	value:12
h	def:D	type:int	value:11
p	def:D	type:proc	value:7

5
rec call: 
5

# using the miniOO part 2:
find var:y
cmd: 0:	var

y	def:U	type:nil	value:0

find num:	1
num:1:	1

cmd: 1:	num
cmd: 0:	var

1
in handle lesser: not defined:	0
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 2	op: <	0	1

find num:	1
num:3:	1
num:1:	1

cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

p = cmd:3;
p	cmd: 3	in proc now.
cmd: 5	left: p	equals cmd:3

find var:p
find var:y
find num:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

nil
not found all the parameter.
nil
0 is not already assigned.
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

cmd: 7	op: -	0	6
cmd: 2	op: <	0	1

4(7)
ready to run:nil	cmd: 4	7
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

rec call: 
8

if else
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

proc y:
p = cmd:9;
p	cmd: 9	in proc now.
now in declare proc.
proc: p	para: y	cmd: 9
find var:p
proc: p	para: y	cmd: 9
find num:	1
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

9(11)
ready to run:p	cmd: 9	11
para: y=11
run cmd: 9
binary operation:	0	<	1
num of 1 : 1
var:	1
1	<	1
num of 1 : 1
var:	1
cmd: 12:	false
cmd: 11
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 6	op: <	4	5

find field:x.C
x.R= cmd:2 as a int
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

7	= cmd:2
0
num:9:	0
num:5:	1
num:3:	0
num:1:	0

cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 8	left: x.R	equals cmd:9
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

find field:x.F
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

find var:y
find num:	1
num:11:	1
num:9:	0
num:5:	1
num:3:	0
num:1:	0

cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

nil
not found all the parameter.
nil
4 is not already assigned.
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 6	op: <	4	5

find field:x.C
x.R= cmd:2 as a int
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

7	= cmd:2
0
num:9:	0
num:5:	1
num:3:	0
num:1:	0

cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 8	left: x.R	equals cmd:9
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

find field:x.F
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

find var:y
find num:	1
num:11:	1
num:9:	0
num:5:	1
num:3:	0
num:1:	0

cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

nil
not found all the parameter.
nil
4 is not already assigned.
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12	op: -	4	11
cmd: 6	op: <	4	5

10(12)
ready to run:nil	cmd: 10	12
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
13

if else
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc y:
x.F= cmd:14 as a proc
10	= cmd:14
now in declare proc.
proc: x.F	para: y	cmd: 14
find field:x.F
proc: x.F	para: y	cmd: 14
find num:	2
num:16:	2
num:11:	1
num:9:	0
num:5:	1
 1:	num
cmd: 0:	obj

19
cond	false:	13
handleCmd:13 with paraid:12
para name:y	run cmd:14
binary operation:	4	-	11
num of 11 : 1
var:	1
1	-	1
num of 11 : 1
var:	1
num:20:	0
num:18:	1
num:16:	2
num:11:	1
num:9:	0
num:5:	1
num:3:	0
num:1:	0

cmd: 20:	num
cmd: 19:	false
cmd: 18:	num
cmd: 17:	false
cmd: 16:	num
cmd: 15:	proc
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:T	type:nil	value:20
x.F	def:U	type:proc	value:14
x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

binary operation:	4	<	5
num of 5 : 1
var:	0
0	<	1
num of 5 : 1
var:	0
cmd: 21:	true
cmd: 20:	num
cmd: 19:	false
cmd: 18:	num
cmd: 17:	false
cmd: 16:	num
cmd: 15:	proc
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

21
cond	true:	8
assignment:	x.R = cmd: 9
0
x.R	def:D	type:int	value:0
y	def:T	type:nil	value:20
x.F	def:U	type:proc	value:14
x.F	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

cmd type not found.
rec call: 
-1

# the end.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 661, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 669, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 832, characters 23-34:
Warning 10: this expression should have type unit.
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

cmd: 1:	var
cmd: 0:	num

h	def:U	type:nil	value:0

h = cmd:0;
1
num:2:	1
num:0:	1

cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

h	def:D	type:int	value:2

find var:y
cmd: 3:	var
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 661, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 669, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 832, characters 23-34:
Warning 10: this expression should have type unit.
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

cmd: 1:	var
cmd: 0:	num

h	def:U	type:nil	value:0

h = cmd:0;
1
num:2:	1
num:0:	1

cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

h	def:D	type:int	value:2

find var:y
cmd: 3:	var
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:D	type:int	value:2

find var:h
y	def:U	type:nil	value:0
h	def:D	type:int	value:2

nil
not found all the parameter.
int
1 is  assigned.
1
num:5:	1
num:2:	1
num:0:	1

cmd: 5:	num
cmd: 3:	var
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

nil
3 is not already assigned.
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

cmd: 4:	binop
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

cmd: 4	op: +	3	5

cmd: 6:	var
cmd: 4:	binop
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

r	def:U	type:nil	value:0
y	def:U	type:nil	value:0
h	def:D	type:int	value:2

r = cmd:4;
r	cmd: 4	in proc now.
cmd: 7	left: r	equals cmd:4

proc y:
cmd: 8:	var
cmd: 7:	ass
cmd: 6:	var
cmd: 4:	binop
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: y
cmd: 0:	var

y	def:U	type:nil	value:0

find num:	1
num:1:	1

cmd: 1:	num
cmd: 0:	var

1
in handle lesser: not defined:	0
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 2	op: <	0	1

find num:	1
num:3:	1
num:1:	1

cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

p = cmd:3;
p	cmd: 3	in proc now.
cmd: 5	left: p	equals cmd:3

find var:p
find var:y
find num:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

nil
not found all the parameter.
nil
0 is not already assigned.
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

cmd: 7	op: -	0	6
cmd: 2	op: <	0	1

4(7)
ready to run:nil	cmd: 4	7
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

rec call: 
8

if else
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

proc y:
p = cmd:9;
p	cmd: 9	in proc now.
now in declare proc.
proc: p	para: y	cmd: 9
find var:p
proc: p	para: y	cmd: 9
find num:	1
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	nuy
cmd: 0:	var

y	def:U	type:nil	value:0

find num:	1
num:1:	1

cmd: 1:	num
cmd: 0:	var

1
in handle lesser: not defined:	0
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 2	op: <	0	1

find num:	1
num:3:	1
num:1:	1

cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

p = cmd:3;
p	cmd: 3	in proc now.
cmd: 5	left: p	equals cmd:3

find var:p
find var:y
find num:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

nil
not found all the parameter.
nil
0 is not already assigned.
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

cmd: 7	op: -	0	6
cmd: 2	op: <	0	1

4(7)
ready to run:nil	cmd: 4	7
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

rec call: 
8

if else
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

proc y:
p = cmd:9;
p	cmd: 9	in proc now.
now in declare proc.
proc: p	para: y	cmd: 9
find var:p
proc: p	para: y	cmd: 9
find num:	1
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

9(11)
ready to run:p	cmd: 9	11
para: y=11
run cmd: 9
binary operation:	0	<	1
num of 1 : 1
var:	1
1	<	1
num of 1 : 1
var:	1
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

12
cond	false:	8
handleCmd:8 with paraid:7
para name:y	run cmd:9
binary operation:	0	-	6
num of 6 : 1
var:	1
1	-	1
num of 6 : 1
var:	1
num:13:	0
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 13:	num
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

y	def:T	type:nil	value:13
p	def:D	type:proc	value:9

binary operatvar
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

find field:x.F
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

find var:y
find num:	1
num:11:	1
num:9:	3
num:5:	1
num:3:	0
num:1:	0

cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

nil
not found all the parameter.
nil
4 is not already assigned.
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12	op: -	4	11
cmd: 6	op: <	4	5

10(12)
ready to run:nil	cmd: 10	12
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
13

if else
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc yvar
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

find field:x.F
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

find var:y
find num:	1
num:11:	1
num:9:	3
num:5:	1
num:3:	0
num:1:	0

cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

nil
not found all the parameter.
nil
4 is not already assigned.
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12	op: -	4	11
cmd: 6	op: <	4	5

10(12)
ready to run:nil	cmd: 10	12
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
13

if else
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc y:
x.F= cmd:14 as a proc
10	= cmd:14
now in declare proc.
proc: x.F	para: y	cmd: 14
find field:x.F
proc: x.F	para: y	cmd: 14
find num:	2
num:16:	2
num:11:	1
num:9:	3
num:5:	1
num:3:	0
num:1:	0

cmd: 16:	num
cmd: 15:	proc
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

14(16)
ready to run:x.F	cmd: 14	16
para: y=16
run cmd: 14
binary operation:	4	<	5
num of 5 : 1
var:	2
2	<	1
num of 5 : 1
var:	2
cmd: 17:	false
cmd: 16:	num
cmd: 15:	proc
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	fef:U	type:nil	value:0
x.R	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

binary operation:	4	<	5
num of 5 : 1
var:	0
0	<	1
num of 5 : 1
var:	0
cmd: 21:	true
cmd: 20:	num
cmd: 19:	false
cmd: 18:	num
cmd: 17:	false
cmd: 16:	num
cmd: 15:	proc
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

21
cond	true:	8
assignment:	x.R = cmd: 9
3
x.R	def:D	type:int	value:3
y	def:T	type:nil	value:20
x.F	def:U	type:proc	value:14
x.F	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

0
rec call: 
0

# the end.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 661, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 669, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 832, characters 23-34:
Warning 10: this expression should have type unit.
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

cmd: 1:	var
cmd: 0:	num

h	def:U	type:nil	value:0

h = cmd:0;
1
num:2:	1
num:0:	1

cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

h	def:D	type:int	value:2

find var:y
cmd: 3:	var
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 661, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 669, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 832, characters 23-34:
Warning 10: this expression should have type unit.
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

cmd: 1:	var
cmd: 0:	num

h	def:U	type:nil	value:0

h = cmd:0;
1
num:2:	1
num:0:	1

cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

h	def:D	type:int	value:2

find var:y
cmd: 3:	var
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:D	type:int	value:2

find var:h
y	def:U	type:nil	value:0
h	def:D	type:int	value:2

nil
not found all the parameter.
int
1 is  assigned.
1
num:5:	1
num:2:	1
num:0:	1

cmd: 5:	num
cmd: 3:	var
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

nil
3 is not already assigned.
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

cmd: 4:	binop
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

cmd: 4	op: +	3	5

cmd: 6:	var
cmd: 4:	binop
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

r	def:U	type:nil	value:0
y	def:U	type:nil	value:0
h	def:D	type:int	value:2

r = cmd:4;
r	cmd: 4	in proc now.
cmd: 7	left: r	equals cmd:4

proc y:
cmd: 8:	var
cmd: 7:	ass
cmd: 6:	var
cmd: 4:	binop
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: y
cmd: 0:	var

y	def:U	type:nil	value:0

find num:	1
num:1:	1

cmd: 1:	num
cmd: 0:	var

1
in handle lesser: not defined:	0
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 2	op: <	0	1

find num:	1
num:3:	1
num:1:	1

cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

p = cmd:3;
p	cmd: 3	in proc now.
cmd: 5	left: p	equals cmd:3

find var:p
find var:y
find num:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

nil
not found all the parameter.
nil
0 is not already assigned.
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

cmd: 7	op: -	0	6
cmd: 2	op: <	0	1

4(7)
ready to run:nil	cmd: 4	7
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

rec call: 
8

if else
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

proc y:
p = cmd:9;
p	cmd: 9	in proc now.
now in declare proc.
proc: p	para: y	cmd: 9
find var:p
proc: p	para: y	cmd: 9
find num:	1
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	nuy
cmd: 0:	var

y	def:U	type:nil	value:0

find num:	1
num:1:	1

cmd: 1:	num
cmd: 0:	var

1
in handle lesser: not defined:	0
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 2	op: <	0	1

find num:	1
num:3:	1
num:1:	1

cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

p = cmd:3;
p	cmd: 3	in proc now.
cmd: 5	left: p	equals cmd:3

find var:p
find var:y
find num:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

nil
not found all the parameter.
nil
0 is not already assigned.
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

cmd: 7	op: -	0	6
cmd: 2	op: <	0	1

4(7)
ready to run:nil	cmd: 4	7
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

rec call: 
8

if else
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

proc y:
p = cmd:9;
p	cmd: 9	in proc now.
now in declare proc.
proc: p	para: y	cmd: 9
find var:p
proc: p	para: y	cmd: 9
find num:	1
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

9(11)
ready to run:p	cmd: 9	11
para: y=11
run cmd: 9
binary operation:	0	<	1
num of 1 : 1
var:	1
1	<	1
num of 1 : 1
var:	1
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

12
cond	false:	8
handleCmd:8 with paraid:7
para name:y	run cmd:9
binary operation:	0	-	6
num of 6 : 1
var:	1
1	-	1
num of 6 : 1
var:	1
num:13:	0
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 13:	num
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

y	def:T	type:nil	value:13
p	def:D	type:proc	value:9

binary operatvar
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

find field:x.F
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

find var:y
find num:	1
num:11:	1
num:9:	3
num:5:	1
num:3:	0
num:1:	0

cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

nil
not found all the parameter.
nil
4 is not already assigned.
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12	op: -	4	11
cmd: 6	op: <	4	5

10(12)
ready to run:nil	cmd: 10	12
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
13

if else
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc yvar
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

find field:x.F
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

find var:y
find num:	1
num:11:	1
num:9:	3
num:5:	1
num:3:	0
num:1:	0

cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

nil
not found all the parameter.
nil
4 is not already assigned.
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12	op: -	4	11
cmd: 6	op: <	4	5

10(12)
ready to run:nil	cmd: 10	12
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
13

if else
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc y:
x.F= cmd:14 as a proc
10	= cmd:14
now in declare proc.
proc: x.F	para: y	cmd: 14
find field:x.F
proc: x.F	para: y	cmd: 14
find num:	2
num:16:	2
num:11:	1
num:9:	3
num:5:	1
num:3:	0
num:1:	0

cmd: 16:	num
cmd: 15:	proc
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

14(16)
ready to run:x.F	cmd: 14	16
para: y=16
run cmd: 14
binary operation:	4	<	5
num of 5 : 1
var:	2
2	<	1
num of 5 : 1
var:	2
cmd: 17:	false
cmd: 16:	num
cmd: 15:	proc
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	fef:U	type:nil	value:0
x.R	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

binary operation:	4	<	5
num of 5 : 1
var:	0
0	<	1
num of 5 : 1
var:	0
cmd: 21:	true
cmd: 20:	num
cmd: 19:	false
cmd: 18:	num
cmd: 17:	false
cmd: 16:	num
cmd: 15:	proc
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

21
cond	true:	8
assignment:	x.R = cmd: 9
3
x.R	def:D	type:int	value:3
y	def:T	type:nil	value:20
x.F	def:U	type:proc	value:14
x.F	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

0
rec call: 
0

# the end.
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 8, characters 19-27:
Error: Unbound type constructor procList
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 41, characters 5-12:
Error: Multiple definition of the type name varList.
       Names must be unique in a given structure or signature.
make: *** [all] Error 2
bash-3.2$ make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 665, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 673, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 836, characters 23-34:
Warning 10: this expression should have type unit.
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

cmd: 1:	var
cmd: 0:	num

h	def:U	type:nil	value:0

h = cmd:0;
1
num:2:	1
num:0:	1

cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

h	def:D	type:int	value:2

find var:y
cmd: 3:	var
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	make
/bin/rm -f calculator calculator.cmi calculator.cmo calculatorLEX.cmi calculatorLEX.cmo calculatorLEX.ml calculatorYACC.cmi calculatorYACC.cmo calculatorYACC.ml calculatorYACC.mli makefile~
ocamllex calculatorLEX.mll
55 states, 3117 transitions, table size 12798 bytes
ocamlyacc calculatorYACC.mly
8 shift/reduce conflicts.
ocamlc -c calculatorYACC.mli
ocamlc -c calculatorLEX.ml
ocamlc -c calculatorYACC.ml
File "calculatorYACC.mly", line 665, characters 12-128:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 673, characters 27-136:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
""
File "calculatorYACC.mly", line 836, characters 23-34:
Warning 10: this expression should have type unit.
ocamlc -c calculator.ml
# linking of the lexer, parser & calculator:
ocamlc -o calculator calculatorLEX.cmo calculatorYACC.cmo calculator.cmo
ls
README				calculatorYACC.cmi
calculator			calculatorYACC.cmo
calculator.cmi			calculatorYACC.ml
calculator.cmo			calculatorYACC.mli
calculator.ml			calculatorYACC.mly
calculatorLEX.cmi		makefile
calculatorLEX.cmo		miniOOfromZhenyi.zip
calculatorLEX.ml		miniOOfromZhenyi_v0.1.zip
calculatorLEX.mll		typescript
# using the miniOO part 1:
find num:	1
num:0:	1

cmd: 0:	num

cmd: 1:	var
cmd: 0:	num

h	def:U	type:nil	value:0

h = cmd:0;
1
num:2:	1
num:0:	1

cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

h	def:D	type:int	value:2

find var:y
cmd: 3:	var
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

y	def:U	type:nil	value:0
h	def:D	type:int	value:2

find var:h
y	def:U	type:nil	value:0
h	def:D	type:int	value:2

nil
not found all the parameter.
int
1 is  assigned.
1
num:5:	1
num:2:	1
num:0:	1

cmd: 5:	num
cmd: 3:	var
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

nil
3 is not already assigned.
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

cmd: 4:	binop
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

cmd: 4	op: +	3	5

cmd: 6:	var
cmd: 4:	binop
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: 1:	var
cmd: 0:	num

r	def:U	type:nil	value:0
y	def:U	type:nil	value:0
h	def:D	type:int	value:2

r = cmd:4;
r	cmd: 4	in proc now.
cmd: 7	left: r	equals cmd:4

proc y:
cmd: 8:	var
cmd: 7:	ass
cmd: 6:	var
cmd: 4:	binop
cmd: 3:	var
cmd: 5:	num
cmd: 2:	num
cmd: y
cmd: 0:	var

y	def:U	type:nil	value:0

find num:	1
num:1:	1

cmd: 1:	num
cmd: 0:	var

1
in handle lesser: not defined:	0
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 2	op: <	0	1

find num:	1
num:3:	1
num:1:	1

cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

p = cmd:3;
p	cmd: 3	in proc now.
cmd: 5	left: p	equals cmd:3

find var:p
find var:y
find num:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

nil
not found all the parameter.
nil
0 is not already assigned.
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

cmd: 7	op: -	0	6
cmd: 2	op: <	0	1

4(7)
ready to run:nil	cmd: 4	7
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

rec call: 
8

if else
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

proc y:
p = cmd:9;
p	cmd: 9	in proc now.
now in declare proc.
proc: p	para: y	cmd: 9
find var:p
proc: p	para: y	cmd: 9
find num:	1
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	nuy
cmd: 0:	var

y	def:U	type:nil	value:0

find num:	1
num:1:	1

cmd: 1:	num
cmd: 0:	var

1
in handle lesser: not defined:	0
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 2	op: <	0	1

find num:	1
num:3:	1
num:1:	1

cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

p = cmd:3;
p	cmd: 3	in proc now.
cmd: 5	left: p	equals cmd:3

find var:p
find var:y
find num:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num
cmd: 0:	var

p	def:U	type:nil	value:0
y	def:U	type:nil	value:0

nil
not found all the parameter.
nil
0 is not already assigned.
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

cmd: 7	op: -	0	6
cmd: 2	op: <	0	1

4(7)
ready to run:nil	cmd: 4	7
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

rec call: 
8

if else
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

proc y:
p = cmd:9;
p	cmd: 9	in proc now.
now in declare proc.
proc: p	para: y	cmd: 9
find var:p
proc: p	para: y	cmd: 9
find num:	1
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

9(11)
ready to run:p	cmd: 9	11
para: y=11
run cmd: 9
binary operation:	0	<	1
num of 1 : 1
var:	1
1	<	1
num of 1 : 1
var:	1
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

12
cond	false:	8
handleCmd:8 with paraid:7
para name:y	run cmd:9
binary operation:	0	-	6
num of 6 : 1
var:	1
1	-	1
num of 6 : 1
var:	1
num:13:	0
num:11:	1
num:6:	1
num:3:	1
num:1:	1

cmd: 13:	num
cmd: 12:	false
cmd: 11:	num
cmd: 10:	proc
cmd: 9:	cond
cmd: 8:	rec
cmd: 7:	binop
cmd: 0:	var
cmd: 6:	num
cmd: 5:	ass
cmd: 4:	var
cmd: 3:	num
cmd: 2:	binop
cmd: 1:	num

y	def:T	type:nil	value:13
p	def:D	type:proc	value:9

binary operatvar
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

find field:x.F
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

find var:y
find num:	1
num:11:	1
num:9:	3
num:5:	1
num:3:	0
num:1:	0

cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

nil
not found all the parameter.
nil
4 is not already assigned.
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12	op: -	4	11
cmd: 6	op: <	4	5

10(12)
ready to run:nil	cmd: 10	12
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
13

if else
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc yvar
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

find field:x.F
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

find var:y
find num:	1
num:11:	1
num:9:	3
num:5:	1
num:3:	0
num:1:	0

cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 4:	var
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
y	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

nil
not found all the parameter.
nil
4 is not already assigned.
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

cmd: 12	op: -	4	11
cmd: 6	op: <	4	5

10(12)
ready to run:nil	cmd: 10	12
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

rec call: 
13

if else
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

proc y:
x.F= cmd:14 as a proc
10	= cmd:14
now in declare proc.
proc: x.F	para: y	cmd: 14
find field:x.F
proc: x.F	para: y	cmd: 14
find num:	2
num:16:	2
num:11:	1
num:9:	3
num:5:	1
num:3:	0
num:1:	0

cmd: 16:	num
cmd: 15:	proc
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

14(16)
ready to run:x.F	cmd: 14	16
para: y=16
run cmd: 14
binary operation:	4	<	5
num of 5 : 1
var:	2
2	<	1
num of 5 : 1
var:	2
cmd: 17:	false
cmd: 16:	num
cmd: 15:	proc
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	fef:U	type:nil	value:0
x.R	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

binary operation:	4	<	5
num of 5 : 1
var:	0
0	<	1
num of 5 : 1
var:	0
cmd: 21:	true
cmd: 20:	num
cmd: 19:	false
cmd: 18:	num
cmd: 17:	false
cmd: 16:	num
cmd: 15:	proc
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

21
cond	true:	8
assignment:	x.R = cmd: 9
3
x.R	def:D	type:int	value:3
y	def:T	type:nil	value:20
x.F	def:U	type:proc	value:14
x.F	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

0
rec call: 
0

# the end.
bash-3.2$ f 5 : 1
var:	1
1	<	1
num of 5 : 1
var:	1
cmd: 19:	false
cmd: 18:	num
cmd: 17:	false
cmd: 16:	num
cmd: 15:	proc
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

19
cond	false:	13
handleCmd:13 with paraid:12
para name:y	run cmd:14
binary operation:	4	-	11
num of 11 : 1
var:	1
1	-	1
num of 11 : 1
var:	1
num:20:	0
num:18:	1
num:16:	2
num:11:	1
num:9:	3
num:5:	1
num:3:	0
num:1:	0

cmd: 20:	num
cmd: 19:	false
cmd: 18:	num
cmd: 17:	false
cmd: 16:	num
cmd: 15:	proc
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

y	def:T	type:nil	value:20
x.F	def:U	type:proc	value:14
x.F	def:U	type:nil	value:0
x.R	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

binary operation:	4	<	5
num of 5 : 1
var:	0
0	<	1
num of 5 : 1
var:	0
cmd: 21:	true
cmd: 20:	num
cmd: 19:	false
cmd: 18:	num
cmd: 17:	false
cmd: 16:	num
cmd: 15:	proc
cmd: 14:	cond
cmd: 13:	rec
cmd: 12:	binop
cmd: 4:	var
cmd: 11:	num
cmd: 10:	field
cmd: 8:	ass
cmd: 9:	num
cmd: 7:	field
cmd: 6:	binop
cmd: 5:	num
cmd: 3:	num
cmd: 2:	field
cmd: 1:	num
cmd: 0:	obj

21
cond	true:	8
assignment:	x.R = cmd: 9
3
x.R	def:D	type:int	value:3
y	def:T	type:nil	value:20
x.F	def:U	type:proc	value:14
x.F	def:U	type:nil	value:0
x.C	def:D	type:int	value:3

0
rec call: 
0

# the end.
bash-3.2$ 